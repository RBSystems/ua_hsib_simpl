#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
  
#DEFINE_CONSTANT	ciMaxDSPPoints		50
#DEFINE_CONSTANT	ciMaxDSPPointsDbl	60
#DEFINE_CONSTANT	ciVolInc			1				//increment size in dB for VolUp and VolDn
#DEFINE_CONSTANT	ciVolDelay1			25				//in ticks, the delay between initial vol push and when it start ramping
#DEFINE_CONSTANT	ciVolDelay2			10				//in ticks, the delay between held vol ramp oscillations
#DEFINE_CONSTANT	ciVolFBRange		936
#DEFINE_CONSTANT	ciMaxFixedPoints	5				//"Fixed" points are function-specific, rather than GUID specific. 
														//e.g. In HSIB, the Lecture panel "Mics Mix" fader will have a Fixed point number, though the associated control point GUIDs
														//may change from room to room


DIGITAL_INPUT	RC_State, 
				_SKIP_, 
				_SKIP_,
				FixedVolUp1[ciMaxFixedPoints],
				_SKIP_,
				FixedVolUp2[ciMaxFixedPoints],
				_SKIP_,
				FixedVolDn1[ciMaxFixedPoints],
				_SKIP_,
				FixedVolDn2[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteOn1[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteOn2[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteOff1[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteOff2[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteTog1[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteTog2[ciMaxFixedPoints],
				_SKIP_, 
				FixedDefaultPoint1[ciMaxFixedPoints],
				_SKIP_,				
				FixedDefaultPoint2[ciMaxFixedPoints],
				_SKIP_, 
				_SKIP_,				
				DSPVolUp1[ciMaxDSPPoints],
				_SKIP_,
				DSPVolUp2[ciMaxDSPPoints],
				_SKIP_,
				DSPVolDn1[ciMaxDSPPoints],
				_SKIP_,
				DSPVolDn2[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteOn1[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteOn2[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteOff1[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteOff2[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteTog1[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteTog2[ciMaxDSPPoints],
				_SKIP_,
				DefaultPointAll[2],
				_SKIP_,
				DefaultPoint1[ciMaxDSPPoints],
				_SKIP_,
				DefaultPoint2[ciMaxDSPPoints, ciMaxDSPPoints];

 
ANALOG_INPUT	_SKIP_,
				PGM_Rte[2],
				_SKIP_, 
				VolFBRange[2],
				_SKIP_,
				Insert2Byte1[ciMaxDSPPoints],
				_SKIP_,
				Insert2Byte2[ciMaxDSPPoints],
				_SKIP_,
				InsertDB1[ciMaxDSPPoints],
				_SKIP_,
				InsertDB2[ciMaxDSPPoints];

BUFFER_INPUT	_SKIP_,
				dataInit_Rx$1[1][5000],
				dataInit_Rx$2[1][5000],
				_SKIP_;

DIGITAL_OUTPUT	_SKIP_, 
				_SKIP_, 
				_SKIP_, 
				_SKIP_, 
				_SKIP_, 
				_SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_,
                _SKIP_,
				FixedMuteFB1[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteFB2[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteNotFB1[ciMaxFixedPoints],
				_SKIP_,
				FixedMuteNotFB2[ciMaxFixedPoints],
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				DSPMuteFB1[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteFB2[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteNotFB1[ciMaxDSPPoints],
				_SKIP_,
				DSPMuteNotFB2[ciMaxDSPPoints],
				_SKIP_;

ANALOG_OUTPUT	FixedVolGaugeFB1[ciMaxFixedPoints],
				_SKIP_,
				FixedVolGaugeFB2[ciMaxFixedPoints],
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				DSPVolGaugeFB1[ciMaxDSPPoints],
				_SKIP_,
				DSPVolGaugeFB2[ciMaxDSPPoints],
				_SKIP_,
				_SKIP_,
				List_NumOfItems[2];

STRING_OUTPUT	_SKIP_,
				DSPVolDBFB$1[ciMaxDSPPoints],
				_SKIP_,
				DSPVolDBFB$2[ciMaxDSPPoints],
				_SKIP_,
				List_FB$1[2],
				List_FB$2[2],
				_SKIP_,
				DSPPointName$1[ciMaxDSPPoints],
				_SKIP_,
				DSPPointName$2[ciMaxDSPPoints, 49],
				_SKIP_;

ANALOG_OUTPUT	DSPVolDB1[ciMaxDSPPoints],
				_SKIP_,
				DSPVolDB2[ciMaxDSPPoints, 49],
				_SKIP_;

                                                                                                            
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////


STRUCTURE stPoint{
				INTEGER			iItemActive;
 
				STRING			sGlobalName[50];
				STRING			sLocalName[50];
				INTEGER			iRmAss;
				INTEGER			iGUID;
 			
				INTEGER			iGroup;							//fader/mute groups
				INTEGER			iFunction;	
				INTEGER			iIsVirtual;	
				INTEGER			iVLink;	

				SIGNED_INTEGER 	siVolState;						//in dB
				INTEGER 		iMuteState;						//1 = muted, 0 = unmuted

				SIGNED_INTEGER	siVolMax;
				SIGNED_INTEGER	siVolMin;
				INTEGER			iVolRange;						//-
				SIGNED_INTEGER	siVolDefault;					//default db value called on DefaultPoint
				INTEGER			iMuteDefault;
				INTEGER			iMuteInverted;					//used for crossPoint muting

				INTEGER			bVolIsDisabled;					//If there is a vol control command, then this Point is a valid volume Point
				INTEGER			bMuteIsDisabled;					//If there is a mute control command, then this Point is a valid mute Point
				INTEGER			bVolDefaultIsDisabled;			//if "~" is placed for the VolDefault KV pair value, Vol default function is ignored 
				INTEGER			bMuteDefaultIsDisabled;			//if "~" is placed for the MuteDefault KV pair value, mute default function is ignored	
			
				INTEGER			iListItemVis;					//is it freaking visible?
				INTEGER			iPointType;						//1 = mics, 2 = line, 3 = router

				INTEGER			iFixedID;						//if the point is associated with a "FixedPoint", then the index of the FixedPoint will be here. Else '0'
			};

STRUCTURE stGroup{
				INTEGER			iNumOfMembers;
              	INTEGER			iGroupMembers[ciMaxDSPPoints];
			};
                  
STRUCTURE stRoom{
				stGroup 		Group[ciMaxDSPPoints];
				INTEGER			iIndexPrimary[ciMaxDSPPoints];
				INTEGER			iIndexRC[ciMaxDSPPoints];

				stPoint 		Point[ciMaxDSPPoints];

				INTEGER			FixedToLocalID[ciMaxFixedPoints];	//to control a Fixed point, it needs a Fixed ID. e.g. FixedPoint[1] is Mics Mix, and it could have an ID of [4], 
																//and it would duplicate the controls and feedback for DSPPoint[4]
				INTEGER			PgmRteIndex;						//the point index associated with the local program audio router

				INTEGER			iRCMute;							//Room Combine mute index
			};

stRoom Room[2];

STRUCTURE stSys{
              	INTEGER			iRCState;
				INTEGER			iIsRCSystem;

			};
stSys Sys;


//-------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------//
        
INTEGER	iGroupSem,
		iVolFBRange[2];
STRING	sTrash[1000];


//-------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------//
 
  
STRING_FUNCTION	fRemWhitespace(STRING sSrc)				//remove whitespace from a string and return the difference
{
	INTEGER i;
	STRING sTemp[100], sTemp2[100];
	sTemp = sSrc;
	while(len(sTemp))
	{
    	i = getc(sTemp);
		if(i >= 0x21 && i <= 0x7e)	sTemp2 = sTemp2 + chr(i);
	}
	return(sTemp2);
}

STRING_FUNCTION fTrueFalse(INTEGER i, INTEGER iInverted)				//inverted is for crossPoint muting (false, rather than true)
{
	if(iInverted) i = !i;
	
	if(i) return("true");
	return("false");
} 
 
INTEGER_FUNCTION fOtherRoom(INTEGER iRoom)
{
	return(3-iRoom);	
}
INTEGER_FUNCTION fOtherList(INTEGER iList)
{
	return(3-iList);	
}
 
//-------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------//
 

FUNCTION fSendListFB(INTEGER iRoom, INTEGER iList, STRING sData)
{
	//trace("in NodeDSP fSendListFB - iRoom = %u, iList = %u, sData = %s", iRoom, iList, sData);
	
	if(iList = 1 || iList = 2)
	{
		switch(iRoom)
		{
			case(1):	List_FB$1[iList]	= sData;
    		case(2):	List_FB$2[iList]	= sData;
		}
	}
}

FUNCTION fUpdateListVis(INTEGER iRoom, INTEGER iList, INTEGER iIndex)				
{
	INTEGER i, j;
	STRING 	sTemp[1000];
     
	
	if(iList=1 || iList=2)
    {
		sTemp = "{ListVisFB:";
		if(iIndex)	makestring(sTemp, "%s%u=%u,;}", sTemp, iIndex, Room[iRoom].Point[iIndex].iListItemVis);
		else
	    {
	  		for(iIndex = 1 to ciMaxDSPPoints)
			{
				if(Room[iRoom].Point[iIndex].iPointType = iList)
				{
		       		makestring(sTemp, "%s%u=%u,", sTemp, iIndex, Room[iRoom].Point[iIndex].iListItemVis); 	
				}  
			}
			makestring(sTemp, "%s;|}", sTemp);
		}
		fSendListFB(iRoom, iList, sTemp);
	}
}

//-------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------//
            
INTEGER_FUNCTION fSetVolFB(INTEGER iRoom, INTEGER iIndex)
{
	INTEGER iVolFB;
	STRING sVolFB[10];
	if(Room[iRoom].Point[iIndex].iVolRange)		iVolFB = (Room[iRoom].Point[iIndex].siVolState 
													- Room[iRoom].Point[iIndex].siVolMin)
														* iVolFBRange[iRoom] 
															/ Room[iRoom].Point[iIndex].iVolRange	;							//set analog gauge FB
	else	return(1);    
	makestring(sVolFB, "%d.0dB", Room[iRoom].Point[iIndex].siVolState);											//string FB e.g. "4.0dB"
	switch(iRoom)
	{
		case(1):
		{
			DSPVolGaugeFB1[iIndex]	= iVolFB;	    	
			DSPVolDBFB$1[iIndex]	= sVolFB;
			DSPVolDB1[iIndex]		= Room[iRoom].Point[iIndex].siVolState;		
			
			if(Room[iRoom].Point[iIndex].iFixedID)					//set FB on Fixed points
			{
				FixedVolGaugeFB1[Room[iRoom].Point[iIndex].iFixedID]	= iVolFB;	    	
			}
                                             
			//other room
			if(Room[iRoom].Point[iIndex].iPointType = 1 || Room[iRoom].Point[iIndex].iPointType = 2)
			{
				DSPVolGaugeFB2[iIndex+25]	= iVolFB;	    	
				//DSPVolDBFB$2[iIndex+25]	= sVolFB;
				//DSPVolDB2[iIndex+25]		= Room[iRoom].Point[iIndex].siVolState;
			}
		}
		case(2):	
		{
			DSPVolGaugeFB2[iIndex]	= iVolFB;
			DSPVolDBFB$2[iIndex]	= sVolFB;		
			DSPVolDB2[iIndex]		= Room[iRoom].Point[iIndex].siVolState;

			if(Room[iRoom].Point[iIndex].iFixedID)					//set FB on Fixed points
			{
				FixedVolGaugeFB2[Room[iRoom].Point[iIndex].iFixedID]	= iVolFB;	    	
			}

			//other room
			if(Room[iRoom].Point[iIndex].iPointType = 1 || Room[iRoom].Point[iIndex].iPointType = 2)
			{
				DSPVolGaugeFB1[iIndex+25]	= iVolFB;	    	
				//DSPVolDBFB$1[iIndex+25]	= sVolFB;
				//DSPVolDB1[iIndex+25]		= Room[iRoom].Point[iIndex].siVolState;
			}		
		}
	}
}

FUNCTION fSetMuteFB(INTEGER iRoom, INTEGER iIndex)
{
    switch(iRoom)
	{
		case(1):
		{
			DSPMuteFB1[iIndex]		= Room[iRoom].Point[iIndex].iMuteState;												//set FB
			DSPMuteNotFB1[iIndex]	= !Room[iRoom].Point[iIndex].iMuteState;

			if(Room[iRoom].Point[iIndex].iFixedID)					//set FB on Fixed points
			{
				FixedMuteFB1[Room[iRoom].Point[iIndex].iFixedID]			= Room[iRoom].Point[iIndex].iMuteState;												//set FB
				FixedMuteNotFB1[Room[iRoom].Point[iIndex].iFixedID]			= !Room[iRoom].Point[iIndex].iMuteState;
			}

			//other room
			if(Room[iRoom].Point[iIndex].iPointType = 1 || Room[iRoom].Point[iIndex].iPointType = 2)
			{
				DSPMuteFB2[iIndex+25]		= Room[iRoom].Point[iIndex].iMuteState;	
				//DSPMuteNotFB2[iIndex+25]	= !Room[iRoom].Point[iIndex].iMuteState;
			}
		}
		case(2):
		{
			DSPMuteFB2[iIndex]		= Room[iRoom].Point[iIndex].iMuteState;												//set FB
			DSPMuteNotFB2[iIndex]	= !Room[iRoom].Point[iIndex].iMuteState;

			if(Room[iRoom].Point[iIndex].iFixedID)					//set FB on Fixed points
			{
				FixedMuteFB2[Room[iRoom].Point[iIndex].iFixedID]			= Room[iRoom].Point[iIndex].iMuteState;												//set FB
				FixedMuteNotFB2[Room[iRoom].Point[iIndex].iFixedID]			= !Room[iRoom].Point[iIndex].iMuteState;
			}

			//other room
			if(Room[iRoom].Point[iIndex].iPointType = 1 || Room[iRoom].Point[iIndex].iPointType = 2)
			{
				DSPMuteFB1[iIndex+25]		= Room[iRoom].Point[iIndex].iMuteState;	
				//DSPMuteNotFB1[iIndex+25]	= !Room[iRoom].Point[iIndex].iMuteState;
			}		
		}
	}
}
 
SIGNED_INTEGER_FUNCTION fCheckBounds(INTEGER iRoom, INTEGER iIndex, SIGNED_INTEGER siVal)				//check the upper and lower bounds of a volume range
{
	return(smin(smax(siVal, Room[iRoom].Point[iIndex].siVolMin), Room[iRoom].Point[iIndex].siVolMax));
}

FUNCTION fSendVol(INTEGER iRoom, INTEGER iIndex)											//new volume state has been assigned at this .Point
{
	INTEGER 		I, K, L;
	STRING 			sVolCmdValue[15];
	STRING			sTemp[10];

	makestring(sVolCmdValue, "%d.0dB", Room[iRoom].Point[iIndex].siVolState);			//set the vol cmd value string
		
	fSetVolFB(iRoom, iIndex);					//set fB
} 


FUNCTION fSendMute(INTEGER iRoom, INTEGER iIndex)											//send mute cmd
{
	INTEGER I, J, K, L;
	STRING	sTemp[10];
    	 
	fSetMuteFB(iRoom, iIndex);
} 

FUNCTION fGroupManager(INTEGER iRoom, INTEGER iIndex, STRING sType)			//most vol and mute commands are sent through here to manage group activity
{
	//INTEGER j, k, l;
	INTEGER iMemberIndex, iGroup, l, iRoomTemp, iMemberIndexTemp;
    
	if(Room[iRoom].Point[iIndex].iGroup  &&  Sys.iRCState)						//if the Room[iRoom].Point has a Group number
																			//this logic removes the ability to create permanent groups in a single classroom, without regard for RC_State
	{
		iGroup = Room[iRoom].Point[iIndex].iGroup;
		for(l = 1 to Room[iRoom].Group[iGroup].iNumOfMembers)				//iterate over all Room[iRoom].Points
		{
			iMemberIndex = Room[iRoom].Group[iGroup].iGroupMembers[l];
			//^^ As of 1.0.77, iMemberIndex is a number between 1 and 100, where 1-50 represents room1, points1-50;  51-100 represents room2, points1-50 
            //ill be amazed if this works the first time.

			iMemberIndexTemp 	= ((iMemberIndex-1) mod 50) + 1;
			iRoomTemp			= ((iMemberIndex-1) / 50) + 1;

			if(findnocase("vol", sType))  								//if sending a vol command
			{
				if(!Room[iRoomTemp].Point[iMemberIndexTemp].bVolIsDisabled && !Room[iRoom].Point[iIndex].bVolIsDisabled)	//and vol commands are not disabled on Room[iRoomTemp].Point iMemberIndexTemp or i
				{
		  			Room[iRoomTemp].Point[iMemberIndexTemp].siVolState = fCheckBounds(iRoom, iIndex, Room[iRoom].Point[iIndex].siVolState);	  		
					fSendVol(iRoomTemp, iMemberIndexTemp);
				}
				else
				{
                   	trace("Node_DSP: Point[%u] Volume control is disabled. Group Vol command blocked at this control Point.", iMemberIndexTemp); 
				}
			}

			else if(findnocase("mute", sType))								//if sending a mute command and CmdMute: is not disabled
			{
				if(!Room[iRoomTemp].Point[iMemberIndexTemp].bMuteIsDisabled && !Room[iRoom].Point[iIndex].bMuteIsDisabled)	//and mute commands are not disabled on Room[iRoomTemp].Point iMemberIndexTemp or i
				{
	        		Room[iRoomTemp].Point[iMemberIndexTemp].iMuteState = Room[iRoom].Point[iIndex].iMuteState;
					fSendMute(iRoomTemp, iMemberIndexTemp);
				}
				else
				{
                   	trace("Node_DSP: Point[%u] Mute control is disabled. Group Mute command blocked at this control Point.", iMemberIndexTemp); 
				}
			}
		}
	}

	else																			//if not in a group
	{
    	if(findnocase("vol", sType)) 			fSendVol(iRoom, iIndex);
		else if(findnocase("mute", sType))		fSendMute(iRoom, iIndex);
	}	
}

FUNCTION fDefaultPoint(INTEGER iRoom, INTEGER iIndex)
{
	if(!Room[iRoom].Point[iIndex].bVolDefaultIsDisabled && !Room[iRoom].Point[iIndex].bVolIsDisabled)
	{
		Room[iRoom].Point[iIndex].siVolState	= Room[iRoom].Point[iIndex].siVolDefault;
		fGroupManager(iRoom, iIndex, "vol");
    }
	else	trace("NodeDSP - fDefaultPoint - Room[iRoom].Point %u, %s: attempted to default a disabled volume field", iIndex, Room[iRoom].Point[iIndex].sGlobalName);
	if(!Room[iRoom].Point[iIndex].bMuteDefaultIsDisabled && !Room[iRoom].Point[iIndex].bMuteIsDisabled)
	{
		Room[iRoom].Point[iIndex].iMuteState	= Room[iRoom].Point[iIndex].iMuteDefault;
		fGroupManager(iRoom, iIndex, "mute");
	}
	else	trace("NodeDSP - fDefaultPoint - Point %u, %s: attempted to default a disabled mute field", iIndex, Room[iRoom].Point[iIndex].sGlobalName);
}

                                                                               
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CHANGE Insert2Byte1
{
	INTEGER i, j, iRoom;

	i = getlastmodifiedarrayindex();
    iRoom = 1;

	if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		j = ((Insert2Byte1[i] * Room[iRoom].Point[i].iVolRange) / iVolFBRange[iRoom]);
		Room[iRoom].Point[i].siVolState = j + Room[iRoom].Point[i].siVolMin;
		fGroupManager(iRoom, i, "vol");	
	}
	else	trace("NodeDSP - Insert2Byte - Point %u, %s: attempted to change a disabled vol field", i, Room[iRoom].Point[i].sGlobalName);
}
CHANGE Insert2Byte2
{
	INTEGER i, j, iRoom;

	i = getlastmodifiedarrayindex();
    iRoom = 2;

	if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		j = ((Insert2Byte2[i] * Room[iRoom].Point[i].iVolRange) / iVolFBRange[iRoom]);
		Room[iRoom].Point[i].siVolState = j + Room[iRoom].Point[i].siVolMin;
		fGroupManager(iRoom, i, "vol");	
	}
	else	trace("NodeDSP - Insert2Byte - Point %u, %s: attempted to change a disabled vol field", i, Room[iRoom].Point[i].sGlobalName);
}

CHANGE InsertDB1
{
	INTEGER i, iRoom;
	SIGNED_INTEGER siInsertDB;

	i = getlastmodifiedarrayindex();
	iRoom = 1;
	
	if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = fCheckBounds(iRoom, i, InsertDB1[i]);
		fGroupManager(iRoom, i, "vol");	
	}
	else	trace("NodeDSP - InsertDB - Point %u, %s: attempted to change a disabled vol field", i, Room[iRoom].Point[i].sGlobalName);
}
CHANGE InsertDB2
{
	INTEGER i, iRoom;
	SIGNED_INTEGER siInsertDB;

	i = getlastmodifiedarrayindex();
	iRoom = 2;
	
	if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = fCheckBounds(iRoom, i, InsertDB2[i]);
		fGroupManager(iRoom, i, "vol");	
	}
	else	trace("NodeDSP - InsertDB - Point %u, %s: attempted to change a disabled vol field", i, Room[iRoom].Point[i].sGlobalName);
}

PUSH DefaultPoint1
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 1;

	fDefaultPoint(iRoom, i);
}
PUSH DefaultPoint2
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 2;

	fDefaultPoint(iRoom, i);
}

PUSH DefaultPointAll										//read help for DefaultPointAll group behavior
{
	INTEGER i, j, k,
			iRoom;
    STRING	sTemp[50],
			sTemp2[200];									//list of group numbers that have been recalled

	iRoom = getlastmodifiedarrayindex();
	
	i = 0;
	for(i = 1 to ciMaxDSPPoints)
	{
		if(Room[iRoom].Point[i].iItemActive)
		{
			if(!Room[iRoom].Point[i].iGroup)								//if the Room[iRoom].Point is not in a group 
			{
				fDefaultPoint(iRoom, i);								//send it
			}
			else												//if the Room[iRoom].Point is in a group
			{
				j = Room[iRoom].Point[i].iGroup; 			
				makestring(sTemp,":%d;", j);
	           	if(!find(sTemp, sTemp2))						//but the group has not been addressed yet
				{
	          		sTemp2 = sTemp2 + sTemp;					//add the new group number 
					if(j <= ciMaxDSPPoints && Room[iRoom].Point[j].iGroup = j && (!Room[iRoom].Point[j].bVolIsDisabled || !Room[iRoom].Point[j].bMuteIsDisabled))
					{											//if the group number Points to its designated default val host
						fDefaultPoint(iRoom, j);						//update the group with the designee
						trace("Node_DSP: DefaultPointAll just propagated Point[%d], which passed the gauntlet.", j);
					}
					else										//if not
					{
	                	fDefaultPoint(iRoom, i);						//update the group with the lowest indexed Point
					}
					if(Room[iRoom].Point[i].bVolDefaultIsDisabled || Room[iRoom].Point[i].bMuteDefaultIsDisabled)
					{
	                	trace("Node_DSP: DefaultPointAll just propagated Point[%d] to group number %dd. This Point has a disabled VolDefault or MuteDefault. Just an FYI.", 
								i, Room[iRoom].Point[i].iGroup);
					}
				}
				else											//index is a group member of a group that has already been recalled
				{
	            	//do nothing
				}
			}	
		}
	}
}

FUNCTION fUpdateRCListItems()
{
	INTEGER i, j, iRoom, iList;
	STRING	sTempVis[2][800];
        
    for(iRoom = 1 to 2)
	{
		for(j = 1 to 2)			sTempVis[j] = "{ListVisFB:";

		for(i = 26 to 50)
		{
        	if(Room[iRoom].Point[i].iPointType = 1 || Room[iRoom].Point[i].iPointType = 2) 
			{
				Room[iRoom].Point[i].iListItemVis	= Sys.iRCState;
                makestring(sTempVis[Room[iRoom].Point[i].iPointType], "%s%u=%u,", sTempVis[Room[iRoom].Point[i].iPointType], i, Sys.iRCState); 	
			} 	
		}

		for(j = 1 to 2)
		{
			makestring(sTempVis[j], "%s;|}", sTempVis[j]);
			fSendListFB(iRoom, j, sTempVis[j]);
		}
	}
}

  
            
RELEASE RC_State												//update group links
{
	INTEGER i, j, k,
			iRoom;
    STRING	sTemp[50],				
			sTemp2[200];									//list of group numbers
    
	Sys.iRCState = !RC_State;
	if(!iGroupSem)
	{

	    iGroupSem = 1;
		delay(100);
	    
        iRoom = 1;
		
		for(i = 1 to ciMaxDSPPoints/2)						
		{
			if(!Room[iRoom].Point[i].iGroup)							//if the Point is not in a group 
			{
				//do nothing
			}
			else if(Room[iRoom].Point[i].iPointType<>3)											//if the Point is in a group
			{
				j = Room[iRoom].Point[i].iGroup; 			
				makestring(sTemp,":%d;", j);
	           	//if
				if(!find(sTemp, sTemp2))					//but the group has not been addressed yet
				{
	          		sTemp2 = sTemp2 + sTemp;				//add the new group number 
					if(j <= ciMaxDSPPoints && Room[iRoom].Point[j].iGroup = j && (!Room[iRoom].Point[j].bVolIsDisabled || !Room[iRoom].Point[j].bMuteIsDisabled))
					{										//if the group number Points to its designated default val host
						fGroupManager(iRoom, j, "vol");					//update the group with the designee
						fGroupManager(iRoom, j, "mute");
						trace("Node_DSP: Group update just propagated Point[%d] with group number %u. Passed the gauntlet.", 
								j, Room[iRoom].Point[j].iGroup);
					}
					else									//If not
					{
	                	fGroupManager(iRoom, i, "vol");					//just update the group with the lowest indexed Point
						fGroupManager(iRoom, i, "mute");
						trace("Node_DSP: Group update just propagated Point[%d] with group number %u based on the Point being the lowest index in the group.",
								i, Room[iRoom].Point[i].iGroup);
					}
				}
				else										//index is a group member of a group that has already been recalled
				{
	            	//do nothing
				}
			}	
		}

		fUpdateRCListItems();
	}
	iGroupSem = 0;

	for(iRoom = 1 to 2)
	{
  		if(Room[iRoom].iRCMute)
		{
        	Room[iRoom].Point[Room[iRoom].iRCMute].iMuteState = 0;
			fSendMute(iRoom, Room[iRoom].iRCMute);
		}  	
	}
}


PUSH RC_State
{
	INTEGER iRoom;

	Sys.iRCState = !RC_State;

	fUpdateRCListItems();

	for(iRoom = 1 to 2)
	{
  		if(Room[iRoom].iRCMute)
		{
        	Room[iRoom].Point[Room[iRoom].iRCMute].iMuteState = 1;
			fSendMute(iRoom, Room[iRoom].iRCMute);
		}  	
	}
}
 
THREADSAFE PUSH DSPVolUp1
{
	INTEGER i, j, iRoom, iExtArryIndex;
	i = getlastmodifiedarrayindex();
	iRoom = 1;
    
	iExtArryIndex = i;
	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
		fGroupManager(iRoom, i, "vol");
		j = 0;
		while(j < ciVolDelay1 && DSPVolUp1[iExtArryIndex])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
       		j = j + 1;
			delay(1);  	
		}
		while(DSPVolUp1[iExtArryIndex])
		{
			Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
    }
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);
	
}
THREADSAFE PUSH DSPVolUp2
{
	INTEGER i, j, iRoom, iExtArryIndex;
	i = getlastmodifiedarrayindex();
	iRoom = 2;

	iExtArryIndex = i;
	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}


    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
		fGroupManager(iRoom, i, "vol");
		j = 0;
		while(j < ciVolDelay1 && DSPVolUp2[iExtArryIndex])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
       		j = j + 1;
			delay(1);  	
		}
		while(DSPVolUp2[iExtArryIndex])
		{
			Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
    }
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);
	
}

THREADSAFE PUSH DSPVolDn1
{
	INTEGER i, j, iRoom, iExtArryIndex;
	i = getlastmodifiedarrayindex();
	iRoom = 1;

	iExtArryIndex = i;
	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}


    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
		fGroupManager(iRoom, i, "vol");
        j = 0;
		while(j < ciVolDelay1 && DSPVolDn1[iExtArryIndex])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
        	j = j + 1;
			delay(1);
		}
		while(DSPVolDn1[iExtArryIndex])
		{
			Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
	}
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);

}
    
THREADSAFE PUSH DSPVolDn2
{
	INTEGER i, j, iRoom, iExtArryIndex;
	i = getlastmodifiedarrayindex();
	iRoom = 2;
        
	iExtArryIndex = i;
	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
		fGroupManager(iRoom, i, "vol");
        j = 0;
		while(j < ciVolDelay1 && DSPVolDn2[iExtArryIndex])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
        	j = j + 1;
			delay(1);
		}
		while(DSPVolDn2[iExtArryIndex])
		{
			Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
	}
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);

}   

PUSH DSPMuteTog1
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 1;

	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}


	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = !Room[iRoom].Point[i].iMuteState;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);

}

PUSH DSPMuteTog2
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 2;
     
	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = !Room[iRoom].Point[i].iMuteState;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);

}

PUSH DSPMuteOn1
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 1;

	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}


	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 1;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}

PUSH DSPMuteOn2
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 2;

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 1;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}

PUSH DSPMuteOff1
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
	iRoom = 1;

	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}


	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 0;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}
PUSH DSPMuteOff2
{
	INTEGER i, iRoom;

	i = getlastmodifiedarrayindex();
    iRoom = 2;

	if(i > 25)
	{
    	i = ( (i-1) mod 25 ) + 1;
		iRoom = fOtherRoom(iRoom);
	}

	
	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 0;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}

//------------------------------------------------------------------------------------------------------------------------//

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------------------------------------//
    
CHANGE PGM_Rte
{
	INTEGER iRoom;
       
	iRoom = getlastmodifiedarrayindex();

	if(Room[iRoom].PgmRteIndex)
	{
  			 if(iRoom = 1)	DSPVolDB1[Room[iRoom].PgmRteIndex] = PGM_Rte[iRoom];
		else if(iRoom = 2)	DSPVolDB2[Room[iRoom].PgmRteIndex] = PGM_Rte[iRoom];  	
	}
}


                                                                               
THREADSAFE PUSH FixedVolUp1
{
	INTEGER i, j, iRoom, iFixed;
	iRoom = 1;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];
	iFixed = getlastmodifiedarrayindex();     

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
		fGroupManager(iRoom, i, "vol");
		j = 0;
		while(j < ciVolDelay1 && FixedVolUp1[iFixed])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
       		j = j + 1;
			delay(1);  	
		}
		while(FixedVolUp1[iFixed])
		{
			Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
    }
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);
	
}
THREADSAFE PUSH FixedVolUp2
{
	INTEGER i, j, iRoom, iFixed;
	iRoom = 2;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];
	iFixed = getlastmodifiedarrayindex();     

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
		fGroupManager(iRoom, i, "vol");
		j = 0;
		while(j < ciVolDelay1 && FixedVolUp2[iFixed])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
       		j = j + 1;
			delay(1);  	
		}
		while(FixedVolUp2[iFixed])
		{
			Room[iRoom].Point[i].siVolState = smin(Room[iRoom].Point[i].siVolState + ciVolInc, Room[iRoom].Point[i].siVolMax);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
    }
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);
	
}

THREADSAFE PUSH FixedVolDn1
{
	INTEGER i, j, iRoom, iFixed;
	iRoom = 1;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];
	iFixed = getlastmodifiedarrayindex();     

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
		fGroupManager(iRoom, i, "vol");
        j = 0;
		while(j < ciVolDelay1 && FixedVolDn1[iFixed])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
        	j = j + 1;
			delay(1);
		}
		while(FixedVolDn1[iFixed])
		{
			Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
	}
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);

}
    
THREADSAFE PUSH FixedVolDn2
{
	INTEGER i, j, iRoom, iFixed;
	iRoom = 2;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];
	iFixed = getlastmodifiedarrayindex();     

    if(!Room[iRoom].Point[i].bVolIsDisabled)
	{
		Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
		fGroupManager(iRoom, i, "vol");
        j = 0;
		while(j < ciVolDelay1 && FixedVolDn2[iFixed])				//this delay will release within 1/100th of a sec if the button is released during the wait
		{
        	j = j + 1;
			delay(1);
		}
		while(FixedVolDn2[iFixed])
		{
			Room[iRoom].Point[i].siVolState = smax(Room[iRoom].Point[i].siVolState - ciVolInc, Room[iRoom].Point[i].siVolMin);
			fGroupManager(iRoom, i, "vol");
			delay(ciVolDelay2);	
		}
	}
    else trace("Node_DSP: User attempmting to ramp vol on Point[%d] which has disabled Volume controls.", i);

}   

PUSH FixedMuteTog1
{
	INTEGER i, iRoom, iFixed;
	iRoom = 1;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = !Room[iRoom].Point[i].iMuteState;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);

}

PUSH FixedMuteTog2
{
	INTEGER i, iRoom, iFixed;
	iRoom = 2;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = !Room[iRoom].Point[i].iMuteState;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);

}

PUSH FixedMuteOn1
{
	INTEGER i, iRoom, iFixed;
	iRoom = 1;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 1;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}

PUSH FixedMuteOn2
{
	INTEGER i, iRoom, iFixed;
	iRoom = 2;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 1;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}

PUSH FixedMuteOff1
{
	INTEGER i, iRoom, iFixed;
	iRoom = 1;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];

	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 0;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}
PUSH FixedMuteOff2
{
	INTEGER i, iRoom, iFixed;
    iRoom = 2;
	i = Room[iRoom].FixedToLocalID[getlastmodifiedarrayindex()];
	
	if(!Room[iRoom].Point[i].bMuteIsDisabled)
	{
		Room[iRoom].Point[i].iMuteState = 0;
		fGroupManager(iRoom, i, "mute");
	}
    else trace("Node_DSP: User attempmting to affect mute on Point[%d] which has disabled Mute controls.", i);
}
  

//---------------------------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------------------//


   
CHANGE VolFBRange
{
	INTEGER i, iRoom;
	iRoom = getlastmodifiedarrayindex();

	if(VolFBRange[iRoom])	iVolFBRange[iRoom] = VolFBRange[iRoom];
	else 					iVolFBRange[iRoom] = ciVolFBRange;
     
	for(i = 1 to ciMaxDSPPoints)
	{
    	fSetVolFB(iRoom, i);
	}
}

//---------------------------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------------------//


FUNCTION fProcessList(INTEGER iRoom)
{
	INTEGER iIndex, iList;
	STRING	sTemp[1000];

	//construct group strings
	//init values
	for(iList = 1 to 2)
	{
		fUpdateListVis(iRoom, iList, 0);
		delay(10);		
	}


	if(Room[iRoom].iRCMute)
	{
       	Room[iRoom].Point[Room[iRoom].iRCMute].iMuteState = !Sys.iRCState;
		fSendMute(iRoom, Room[iRoom].iRCMute);
	}  	
}

FUNCTION fProcessLine(INTEGER iRoom, INTEGER iType, INTEGER iIndex, STRING sTempLineArg)
{
	INTEGER i,
			iPointType,
			iErr,
			iGroup;
	STRING  sTempKey[50],
			sTempValue[100],
			sTempPair[151],
			sTempLine[300],
			sTempHeader[100];

	sTempLine = sTempLineArg;

	while(find(",", sTempLine))
	{
   		sTempPair 	= remove(",", sTempLine);
		sTempKey	= remove("=", sTempPair);
		sTempValue	= left(sTempPair, len(sTempPair) - 1);
    
   			 if(findnocase("global_name", sTempKey))       	Room[iRoom].Point[iIndex].sGlobalName		= sTempValue;
   		else if(findnocase("local_name", sTempKey))		   	Room[iRoom].Point[iIndex].sLocalName		= sTempValue;
        else if(findnocase("room", sTempKey))				Room[iRoom].Point[iIndex].iRmAss			= atoi(sTempValue);
        else if(findnocase("guid", sTempKey))       		Room[iRoom].Point[iIndex].iGUID				= atoi(sTempValue);
        else if(findnocase("fixed_id", sTempKey))
		{
			Room[iRoom].Point[iIndex].iFixedID					= atoi(sTempValue);
			Room[iRoom].FixedToLocalID[atoi(sTempValue)]		= iIndex;
		}
        else if(findnocase("group", sTempKey))				Room[iRoom].Point[iIndex].iGroup			= atoi(sTempValue);
        else if(findnocase("is_virtual", sTempKey))			Room[iRoom].Point[iIndex].iIsVirtual		= atoi(sTempValue);
        else if(findnocase("range_max", sTempKey))			Room[iRoom].Point[iIndex].siVolMax			= atosi(sTempValue);
        else if(findnocase("range_min", sTempKey))			Room[iRoom].Point[iIndex].siVolMin			= atosi(sTempValue);
        else if(findnocase("default_vol", sTempKey))		Room[iRoom].Point[iIndex].siVolDefault		= atosi(sTempValue);
        else if(findnocase("default_mute", sTempKey))		Room[iRoom].Point[iIndex].iMuteDefault		= atoi(sTempValue);
        else if(findnocase("vol_disabled", sTempKey))		Room[iRoom].Point[iIndex].bVolIsDisabled	= atoi(sTempValue);
        else if(findnocase("mute_disabled", sTempKey))		Room[iRoom].Point[iIndex].bMuteIsDisabled	= atoi(sTempValue);
        else if(findnocase("point_type", sTempKey))			Room[iRoom].Point[iIndex].iPointType		= atoi(sTempValue);
        else if(findnocase("function", sTempKey))			Room[iRoom].Point[iIndex].iFunction			= atoi(sTempValue);
        else
		{
			iErr = 1;
			trace("NodeDSP - fProcessLine error - didn't catch key - type=%u, GUID=%u, key=%s, value=%s", iType, iIndex, sTempKey, sTempValue);
		}
	}

	if(!iErr)									//if no error on the data line					
	{
                         
        switch(Room[iRoom].Point[iIndex].iFunction)
		{
        	case(0):	{}
			case(1):				//rc mute
			{
				Room[iRoom].iRCMute	= iIndex;
				Room[iRoom].Point[iIndex].bMuteDefaultIsDisabled	= 1;
			}
		}
		
		
		if(Room[iRoom].Point[iIndex].iPointType	= 3)
			Room[iRoom].PgmRteIndex = iIndex;

        iPointType 												= Room[iRoom].Point[iIndex].iPointType;  
		
       	Room[iRoom].Point[iIndex].iItemActive					= 1;
		Room[iRoom].Point[iIndex].iVolRange						= Room[iRoom].Point[iIndex].siVolMax - Room[iRoom].Point[iIndex].siVolMin;
		Room[iRoom].iIndexPrimary[iIndex] 						= 1;
		//assign the RC index list item [iIndex+25] 			= 1
		Room[fOtherRoom(iRoom)].iIndexRC[iIndex+25] 			= 1; 
        Room[fOtherRoom(iRoom)].Point[iIndex+25].iPointType		= iPointType;
		//if the total VolRange is 0 or less than 0 (notated as > 50000 in unsigned territory)
		if(Room[iRoom].Point[iIndex].iVolRange = 0 || Room[iRoom].Point[iIndex].iVolRange > 50000)	
		{	//back to inactive
			Room[iRoom].Point[iIndex].iItemActive	= 0;
        	//trace dat err
			trace("NodeDSP - error parsing iRoom=%u, iIndex=%u - iVolRange calculated to be zero", iRoom, iIndex);
		}
		//if the new point has a group association:
		if(Room[iRoom].Point[iIndex].iGroup)
		{	//grab the group_ass
			iGroup = Room[iRoom].Point[iIndex].iGroup;
        	//increment the iNumOfMembers in the group
			Room[			iRoom ].Group[iGroup].iNumOfMembers	= Room[			  iRoom ].Group[iGroup].iNumOfMembers + 1;
			Room[fOtherRoom(iRoom)].Group[iGroup].iNumOfMembers	= Room[fOtherRoom(iRoom)].Group[iGroup].iNumOfMembers + 1;
			//use the updated NumOfMembers as the iGroupMembers[] array index to store the new member data e.g. Point.iGroupMembers[iNumOfMembers] = Point.iFixedID
			Room[			iRoom ].Group[iGroup].iGroupMembers[Room[iRoom].Group[iGroup].iNumOfMembers] = iIndex + ((iRoom-1)*ciMaxDSPPoints);
			Room[fOtherRoom(iRoom)].Group[iGroup].iGroupMembers[Room[iRoom].Group[iGroup].iNumOfMembers] = iIndex + ((iRoom-1)*ciMaxDSPPoints);
                                                                                                                                                             
			//
			//
			//^^ this is different as of 1.0.77. Both rooms will share both group member lists, where room 2 gets +50 added on. (so 1-50=room 1, 51-100=room2)
			//
			//
		}
		//update point tag / text / FB
		switch(iRoom)
		{
        	case(1):
			{	//primary point update
         		DSPPointName$1[iIndex] 				= Room[iRoom].Point[iIndex].sGlobalName; 
				//same data, but RC point, and iIndex + 25
				DSPPointName$2[iIndex+25] 			= Room[iRoom].Point[iIndex].sGlobalName;  	
			}
			case(2):
			{
            	DSPPointName$2[iIndex] 				= Room[iRoom].Point[iIndex].sGlobalName;
				DSPPointName$1[iIndex+25] 			= Room[iRoom].Point[iIndex].sGlobalName;  	
			}
		}
		//set point visibility
		if(iPointType = 1  ||   iPointType = 2)
		{
			Room[iRoom].Point[iIndex].iListItemVis	= 1;
			fUpdateListVis(iRoom, iPointType, iIndex);
			
			Room[fOtherRoom(iRoom)].Point[iIndex+25].iListItemVis	= Sys.iRCState;
			fUpdateListVis(fOtherRoom(iRoom), iPointType, iIndex+25);
        }
	}
}

FUNCTION fProcessInit(INTEGER iRoom, STRING sTempInitData)
{
	INTEGER i, j, iIndex,
			iType;
	
	STRING 	sTempData[1000], 
			sTempHeader[100], 
			sTempGUID[20], 
			sTempLine[300];

	sTempData 	= sTempInitData;				//"{MTRX_VDST; GUID=014: friendly_name=MyFriendlyLCD, room_ass=02, Fixed_id=4, is_permissed=true, filter_id=3, virtual=false, cmd_data=143| }"
	sTempHeader = remove(";", sTempData);		//"{MTRX_VDST;"

		 if(findnocase("DSP_POINTS", sTempHeader))			iType = 1;
    else if(findnocase("DSP_PRESETS", sTempHeader))			iType = 2;
    else if(findnocase("ROOMS", sTempHeader))				iType = 13;
	else trace("NodeDSP - in fProcessInit - didn't catch header type - %s", sTempHeader);

	while(find("|", sTempData))
	{
    	sTempLine 	= remove("|", sTempData);	//"GUID=014: friendly_name=MyFriendlyLCD, room_ass=02, Fixed_id=4, is_permissed=true, filter_id=3, virtual=false, cmd_data=143|"
		if(findnocase("complete", sTempLine))		
		{
			delay(10);
			fProcessList(iRoom);
		}
		else
		{
			sTempGUID	= remove(":", sTempLine);   //"GUID=014:", "RoomID=021:", "FixedID=04:"
			iIndex		= atoi(sTempGUID);

  			if(iIndex)
			{
				switch(iType)
				{
					case(1):
					{
						Room[iRoom].Point[iIndex].siVolMax		= 6;
						Room[iRoom].Point[iIndex].siVolMin		= -20;
						Room[iRoom].Point[iIndex].iVolRange		= 26;
						Room[iRoom].Point[iIndex].iMuteDefault	= 0;
						Room[iRoom].Point[iIndex].siVolDefault	= 0;
                                    
						fProcessLine(iRoom, iType, iIndex, sTempLine);
					}
					//case(2):	fProcessPreset(iType, iIndex, sTempLine);
					//case(13):	fProcessRooms(iType, iIndex, sTempLine);
				}
            }
			else	trace("NodeDSP - fProcessInit error, iIndex did not resolve -    %s %u %s", sTempHeader, iIndex, sTempLine);
		}
	}	
}

//---------------------------------------------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------------------------------------//

THREADSAFE CHANGE dataInit_Rx$1
{
	INTEGER i, iRoom;
	STRING sTemp[1200];
    iRoom = 1;
	while(find("}", dataInit_Rx$1[1]))
	{
    	sTemp = gather("}", dataInit_Rx$1[1]);
		fProcessInit(iRoom, sTemp);
	}
}

THREADSAFE CHANGE dataInit_Rx$2
{
	INTEGER i, iRoom;
	STRING sTemp[1200];
    iRoom = 2;
	while(find("}", dataInit_Rx$2[1]))
	{
    	sTemp = gather("}", dataInit_Rx$2[1]);
		fProcessInit(iRoom, sTemp);
	}
}

//---------------------------------------------------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------------------------------------//
 
FUNCTION main()
{
	INTEGER i, j;
	STRING	sTemp[1000], sTemp2[20];

	waitforinitializationcomplete();
    
	for(i = 1 to 2)       
	{
		if(VolFBRange[i])	iVolFBRange[i] = VolFBRange[i];				//if analog input iVolFBRange has a value, use it rather than the ciVolFBRange
		else 				iVolFBRange[i] = ciVolFBRange;
    }
}

