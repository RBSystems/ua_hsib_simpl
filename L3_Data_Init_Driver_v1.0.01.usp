#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
#DIGITAL_EXPAND 	allWithAny 

#DEFINE_CONSTANT	ciMaxNumLines	20

#HELP_BEGIN
v1.0.01 - removed nviEnable and associated IO. Now just operates based on digital input "Disable".
Use a digital_RAM or similar to drive the digital input high.
On startup, module waits <delay_time> before running any incoming start commands.
e.g. if delay_time is 1000t, then:
- processor boots
- waitforinitializationcomplete()
- wait(1000t)
- user triggers start during the wait
- wait expires, sees the triggered start event, and pulses the first output (assuming 'Disable' is not propagated) 
#HELP_END    


DIGITAL_INPUT	Disable,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				Start,
				Stop,
				_SKIP_,
				_SKIP_,
				Done[ciMaxNumLines, 5];


DIGITAL_OUTPUT  _SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				Busy_FB,
				Done_FB,
				_SKIP_,
				_SKIP_,
				Trig[ciMaxNumLines, 5];
				

INTEGER_PARAMETER 	_SKIP_,
					_SKIP_,
					highest_index_used,
					delay_time;

#BEGIN_PARAMETER_PROPERTIES highest_index_used
propValidUnits		= unitDecimal;
propBounds			= 1d, 100d;
propDefaultValue	= 1d;
#END_PARAMETER_PROPERTIES
#BEGIN_PARAMETER_PROPERTIES delay_time
propValidUnits		= unitTicks;
propDefaultValue	= 10t;
#END_PARAMETER_PROPERTIES
  

INTEGER	iIndex, iStopSem, iStartSem, iInitialized;

FUNCTION fStart()
{
	if(iInitialized  && !Disable)
	{
		trace("%s.%03u  ______DataInit: Start_//\x0d\x0a", time(), gethseconds());

		iStopSem = 0;
		iStartSem = 0;
		Busy_FB	= 1;
		if(iIndex = 0)		iIndex = 1;
		pulse(10, Trig[iIndex]);
	}
	else if(!iInitialized)
	{

    	iStartSem = 1;
	}
}

     
PUSH Start
{
	fStart();
}
   
PUSH Stop
{
	iStopSem = 1;
}


PUSH Done
{
	if(!Disable)
	{
		Done_FB	= 0;
		Busy_FB	= 1;

		iIndex = getlastmodifiedarrayindex() + 1;
	

		if(iIndex <= highest_index_used)
		{
			if(!iStopSem)
			{
				delay(delay_time);
				Busy_FB	= 1;
				pulse(10, Trig[iIndex]);
			}
			else
			{
			trace("%s.%03u  ______DataInit: Stopped_//\x0d\x0a", time(), gethseconds());
            	
			}
		}
		else
		{
			trace("%s.%03u  ______DataInit: Complete_//\x0d\x0a", time(), gethseconds());
        	Busy_FB	= 0;
			Done_FB	= 1;
			iStopSem = 1;
			iIndex = 1;
		}
	}
}


FUNCTION main()
{

	waitforinitializationcomplete();

	iIndex = 1;

	wait(delay_time)
	{
		iInitialized = 1;
    	if(iStartSem)
		{
			Busy_FB	= 1;
			pulse(10, Trig[iIndex]);
			iStartSem = 0;
		}	
	}
}
