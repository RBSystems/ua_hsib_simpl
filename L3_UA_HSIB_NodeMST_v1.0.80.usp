#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
 
       
#INCLUDEPATH "C:\Users\bcampagnola\Documents\L3AV\ProgResources\L3_Tools\L3_Tools\bin\debug"
#USER_SIMPLSHARP_LIBRARY "L3_Tools"



#DEFINE_CONSTANT	ciMaxNumCams			10
#DEFINE_CONSTANT	ciMaxNumDisplays		40
#DEFINE_CONSTANT	ciMaxNumCamPresets		16
#DEFINE_CONSTANT    ciMaxNumListItems		50
#DEFINE_CONSTANT    ciMaxNumLists			4		
#DEFINE_CONSTANT	ciMaxNumSrc				50
#DEFINE_CONSTANT	ciMaxNumDst				50
#DEFINE_CONSTANT	ciMaxNumGlobalMTRXio	400
#DEFINE_CONSTANT	ciMaxNumMacros			5

#DEFINE_CONSTANT	ciLocalSrcID_Aux		4
#DEFINE_CONSTANT	ciLocalSrcID_VTC1		5
#DEFINE_CONSTANT	ciLocalSrcID_VTC2		6
                                             
#DEFINE_CONSTANT	ciList_MTRX_AdminVSrc	1
#DEFINE_CONSTANT	ciList_MTRX_AdminVDst	2
#DEFINE_CONSTANT	ciList_MTRX_MacroSrc	5
#DEFINE_CONSTANT	ciList_MTRX_MacroDst	6

#DEFINE_CONSTANT	ciConfMonLocal			49
#DEFINE_CONSTANT	ciSourcePC				2

#DEFINE_CONSTANT	ciMacroConf				5

#DEFINE_CONSTANT	ciMaxNum_LocalSrc		20		//this is the max number of sources available on the main presentation page, non SG
		

DIGITAL_INPUT	_SKIP_, _SKIP_, 
				RC_On[2],
				RC_Off[2],
				RC_Tog[2],
				_SKIP_,
				PartSenseSignal[1],
				_SKIP_,
				PartSense_Enable[2],
				PartSense_Disable[2],
				_SKIP_,
				SYS_PowerOn[2],
				SYS_PowerOff[2],
				_SKIP_,
                MTRX_Take[2],
				MTRX_Clear[2],
				MTRX_SelAll[2],
				_SKIP_,
				_SKIP_,
				Cam_Tilt_Up[2],
				Cam_Tilt_Dn[2],
				Cam_Pan_Left[2],
				Cam_Pan_Right[2],
				Cam_Zoom_Tight[2],
				Cam_Zoom_Wide[2],
				Cam_Focus_Near[2],
				Cam_Focus_Far[2],
				Cam_Power_On[2],
				Cam_Power_Off[2],
				Cam_Power_Tog[2],
				_SKIP_;

ANALOG_INPUT	Sys_Preset[2],
				_SKIP_,
				UI_Page[2],
				UI_Sub[2],
				_SKIP_,
				Cam_Select[2],
				_SKIP_,
				Cam_Preset_Recall[2],
				_SKIP_,
				_SKIP_,
				MTRX_Macro1_Src[ciMaxNumMacros],
				_SKIP_,
				MTRX_Macro2_Src[ciMaxNumMacros],
				_SKIP_,
				MTRX_Macro1_Dst[1],
				_SKIP_,
				MTRX_Macro2_Dst[1],
				_SKIP_,
				MTRX_AdminVSrc_Clicked[2],
				MTRX_AdminVDst_Clicked[2],
				_SKIP_,
				//DSP_Mics_Clicked[2],
				//DSP_Line_Clicked[2],
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				
				_SKIP_;
				
BUFFER_INPUT	from_Global_Rx$_1[1][5000],
				from_Global_Rx$_2[1][5000],
				_SKIP_;                

DIGITAL_OUTPUT	_SKIP_, _SKIP_, 
				RC_On_FB[2],
				RC_Off_FB[2],
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
				PartSense_Enable_FB[2],
				PartSense_Disable_FB[2],
				_SKIP_,
				SYS_PowerOn_Go[2],
				SYS_PowerOff_Go[2],
				_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_,
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, _SKIP_, 
                _SKIP_,
				Cam_Power_On_FB[2],
				Cam_Power_Off_FB[2],
				_SKIP_,
				_SKIP_;

ANALOG_OUTPUT	_SKIP_,
				_SKIP_,
				_SKIP_,
				_SKIP_, 
				_SKIP_, 
				DSP_PGM_Rte[2], 
				_SKIP_, 
				_SKIP_, 
				_SKIP_, 
				MTRX_Macro1_Src_FB[ciMaxNumMacros],
				_SKIP_,
				MTRX_Macro2_Src_FB[ciMaxNumMacros],
				_SKIP_,
				MTRX_AdminVSrc_NumOfItems[2],
				MTRX_AdminVDst_NumOfItems[2],
				_SKIP_,
				DSP_Mics_NumOfItems[2],
				DSP_Line_NumOfItems[2],
				_SKIP_;

STRING_OUTPUT	to_MST_Tx$[2],
				_SKIP_,
				_SKIP_,
				to_DSP_Tx$[2],
				_SKIP_,
				MTRX_AdminVSrc_FB$[2],
				MTRX_AdminVDst_FB$[2],
				_SKIP_,
				DSP_Mics_FB$[2],
				DSP_Line_FB$[2],
				_SKIP_,
				_SKIP_,
				CAM_FB$[2],
				CAM_Presets_FB$[2],
				Display_FB$[2],
				MTRX_Macro_Src_FB$[2],
				MTRX_Macro_Dst_FB$[2],
				RoomName$_Out[2,2];



//----------------------------------------------------------------------------------------------//

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  Data

//----------------------------------------------------------------------------------------------//


STRUCTURE stListItem {
				INTEGER iItemActive,							//identifies which arrayed items have been populated by init data
             			iFB,		
						iVis,
						iIcon;
				STRING  sText[4][50];
				//stIO	Data;

	           	STRING 	sGlobalName[40];						//global label - "Rm 320 Laptop" 						
            	STRING 	sLocalName[40];							//local, generic label - "PC", "Wireless" ,etc						
				INTEGER iRmAss,									//associated room
						iGUID,									//global index for sending upstream
						iFunctionID,							//arbitrary id used to match IO with others of similar function
						iFilterID,								//global matrix filter IO
						iIsVirtual,								//isVirtual=does not have a fixed GUID at the local level (e.g. the aux vid feed)
						iVLink,									//integer of the virtual's linked global index. 0 when not linked
						iIsRCItem;								//isRCItem=this list item only appears when the rooms are combined
				INTEGER iRoutedSrc;								//only for MTRX points - GUID of the source routed to dst (used with Dst only)
				STRING	sRoutedSrc[50];							//string global_name of the routed source
				INTEGER iLastRouteReq,							//
						iMuteState,								//only for DSP points
						iVolState;								//	
				INTEGER iIsCamera;
				INTEGER iIsDisplay;
				INTEGER iCamLocalID;
				INTEGER iCamGUID;
				INTEGER iDisplayLocalID;
				INTEGER iDisplayGUID;

				INTEGER iSysPreset;								//special system macro assignment

				INTEGER iIsUSB;									//generally, if a source/destination is associated with a USB endpoint

				INTEGER iIsAudioDst;							//audio destinations are noted here (just with '1')

				INTEGER iPGMAudio;								//if the source is a program audio router source, store the input# here

			};

STRUCTURE stList	{
             	stListItem Item[ciMaxNumListItems];
				INTEGER iMaxNumItems,
						iNumOfTextColumns,
						iListUsesFB,
						iListUsesVis,
						iListUsesIcon,
						iListUsesText,
						iGlobalToLocal[ciMaxNumGlobalMTRXio],
						iItemSelected,
						iNumOfItemsSelected;					//only used for MTRX outputs, etc
			};
                    

STRUCTURE stMacroList	{
              	INTEGER iNumOfObjects;
				INTEGER iList[30];
				INTEGER iPrimaryObject;							//this is the object that is used for tracking the feedback state for the macro  
				INTEGER iState;									//video macro state number (usually, the local source number is assigned to this value)
			};

STRUCTURE stMacro	{											//	
				INTEGER iItemActive;
             	STRING  sName[50];								//
				stMacroList List[2];			//[1] all the regular actions of the macro - 		e.g. on shutdown, we zero out the VDst items in this list
									        	//[2] inverted / opposite actions of the macro - 	e.g. but after that is complete, we re-initialize the PC route to the DGE
						
              	INTEGER iVis;
				INTEGER iFB;

				INTEGER iUSB;									//is this macro the USB link?
				INTEGER iPgmAudio;								//is this macro the pgm audio a_link?
			};			

STRUCTURE stPreset	{
              	INTEGER iPresetActive;
				STRING	sPresetName[30];
			};

STRUCTURE stCam		{
				INTEGER iCamActive;
                            
				STRING	sGlobalName[40];
				STRING	sLocalName[40];

				INTEGER iSysPreset;

             	INTEGER	iFB;		
				INTEGER iVis;

              	INTEGER iCamGUID;

				INTEGER iVSrcLocalID;
				INTEGER iVSrcGUID;
                
                INTEGER iCamPowerState;
				INTEGER iCamPresetState;
				
				stPreset	Preset[16];
			};

STRUCTURE stDisplay	{
              	INTEGER iDisplayActive;

				STRING	sGlobalName[40];
				STRING	sLocalName[40];

				INTEGER iSysPreset;

				INTEGER iFB;
				INTEGER iVis;

				INTEGER iDisplayGUID;
				INTEGER iVDstLocalID;
				INTEGER iVDstGUID;

				INTEGER iDisplayPowerState;
				INTEGER iDisplayInputState;
			};
              
STRUCTURE stRoom 	{
				INTEGER iRoomActive;
             	INTEGER iRoomGUID;								//this room's GUID
				STRING	sRoomName[30];							//friendly name for the room  (e.g. "Lecture Room 321"
				STRING	sRoomNameShort[20];						//Used to make GLobal IO names, e.g. "Rm 320" --> "Rm 320 Laptop"
				INTEGER iBldgRoomNum;							//building location room# (e.g. 320)

				INTEGER iDiscreteMacroMode;						//macro/switching behavior (1 = discrete macro output groups, 0 = matrix style)
				INTEGER iMacroTakeMode;							//macro/switching behavior (1= use 'take' button, 0 = route immediately on dst press)
				INTEGER iUseSrcListMode;						//tells macro/switching to use the admin source list as the MTRX source signal

				INTEGER iCamSel;
				stCam	Cam[ciMaxNumCams];

				INTEGER iDisplaySel;
				stDisplay	Display[ciMaxNumDisplays];
            	
				INTEGER iSysPowerState;							//the room power state
				INTEGER	iVTCAllocation;							//0 = none, 1-3 = the Cisco SX80 unit numbers

				stList	List[5];								//LocalSrc, LocalDst, DSPMics, DSPLine, MainSrc	
                                                                           
				stMacro	Macro[60];								//[1-25] 	VDst Outputs 	(listObjects = VDstLocalID)
																//[26]		USB only		(listObjects = VDstLocalID)
																//[27]		PGM audio only  (listObject  = VSrcLocalID) 
																//[28-30]
																//[31-40] 	Displays Power	(listObjects = VDstLocalID)
																//[41-56] 	Cam Presets		(listObjects = CamLocalID)	
																//[57]		SystemOn 	Uncombined	(listObjects = MacroID)
																//[58]  	SystemOff 	Uncombined	(listObjects = MacroID)
																//[59]		SystemOn	Combined	(listObjects = MacroID)
																//[60]		SystemOff	Combined	(listObjects = MacroID)  				
                             
				INTEGER iLastSrcSel[20][20];					//tracks the last main page video macro source pressed for each page, arrayed by [Page][Sub]. 
                                   
				INTEGER iUI_Page;
				INTEGER iUI_Sub;

			};

stRoom Room[2];

STRUCTURE stSys {
				INTEGER iRCState,
						iPartitionState,
						iPartitionEnabled,
						iIsRCPair;	
			};                  

stSys Sys;
           
StringTools ST;


STRING sTrash[1000];     
 
//----------------------------------------------------------------------------------------------//

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  Utility

//----------------------------------------------------------------------------------------------//
  
       
INTEGER_FUNCTION fIsCharPrintable(INTEGER iTemp)
{
	if(iTemp >= 33  &&  iTemp <= 126)		return(1);
	return(0);
}

STRING_FUNCTION fTrimWhitespace(STRING sTemp)
{
	//removes non-printable characters from front and back of a string
	INTEGER iTempC;
	STRING sData[1000], sTempC[1];
    
    if(!len(sTemp))		return("");
	
	sData = sTemp;
	iTempC = getc(sData);
	while(!fIsCharPrintable(iTempC))
	{                                       
		if(!len(sData))		return("");
    	iTempC = getc(sData);	
	}
	sData = chr(iTempC) + sData;
	if(len(sData) <= 1)			return(sData);
        
	sTempC = right(sData, 1);
	iTempC = getc(sTempC);
	while(!fIsCharPrintable(iTempC))
	{
    	if(!len(sData))		return("");		//this wont ever happen... probably
		sData = left(sData, len(sData) - 1);
		sTempC = right(sData, 1);
		iTempC = getc(sTempC);
	}

	return(sData);
}
        
INTEGER_FUNCTION fGetNumItemsSelected(INTEGER iRoom, INTEGER iList)
{
	INTEGER i, iCount;
	for(i = 1 to Room[iRoom].List[iList].iMaxNumItems)
	{
    	if(Room[iRoom].List[iList].Item[i].iFB  &&  Room[iRoom].List[iList].Item[i].iItemActive)	iCount = iCount + 1;
	}

	return(iCount);
}

INTEGER_FUNCTION fOtherRoom(INTEGER iRoom)
{
	return(3-iRoom);
}
          
FUNCTION fCopyIO(INTEGER iFromRoom, INTEGER iFromIndex, INTEGER iToRoom, INTEGER iToIndex, INTEGER iList)
{
   	Room[iToRoom].List[iList].Item[iToIndex].iItemActive	= Room[iFromRoom].List[iList].Item[iFromIndex].iItemActive	;
   	Room[iToRoom].List[iList].Item[iToIndex].sGlobalName	= Room[iFromRoom].List[iList].Item[iFromIndex].sGlobalName	;
   	Room[iToRoom].List[iList].Item[iToIndex].sLocalName		= Room[iFromRoom].List[iList].Item[iFromIndex].sLocalName	;
   	Room[iToRoom].List[iList].Item[iToIndex].iRmAss			= Room[iFromRoom].List[iList].Item[iFromIndex].iRmAss		;
   	Room[iToRoom].List[iList].Item[iToIndex].iGUID			= Room[iFromRoom].List[iList].Item[iFromIndex].iGUID		;
   	Room[iToRoom].List[iList].Item[iToIndex].iFunctionID	= Room[iFromRoom].List[iList].Item[iFromIndex].iFunctionID	;
   	Room[iToRoom].List[iList].Item[iToIndex].iFilterID		= Room[iFromRoom].List[iList].Item[iFromIndex].iFilterID	;
   	Room[iToRoom].List[iList].Item[iToIndex].iIsVirtual		= Room[iFromRoom].List[iList].Item[iFromIndex].iIsVirtual	;
   	Room[iToRoom].List[iList].Item[iToIndex].iVLink			= Room[iFromRoom].List[iList].Item[iFromIndex].iVLink		;	

	switch(iList)
	{
    	case(2):
		{
   			Room[iToRoom].List[iList].Item[iToIndex].iRoutedSrc		= Room[iFromRoom].List[iList].Item[iFromIndex].iRoutedSrc		;
   			Room[iToRoom].List[iList].Item[iToIndex].sRoutedSrc		= Room[iFromRoom].List[iList].Item[iFromIndex].sRoutedSrc		;
		}
	}
}

   
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	 Output data and UI feedback


FUNCTION fSendListFB(INTEGER iRoom, INTEGER iList, STRING sData)
{
	switch(iList)
	{
    	case(1):	MTRX_AdminVSrc_FB$[iRoom]	= sData;
		case(2):	MTRX_AdminVDst_FB$[iRoom]	= sData;
		case(3):	DSP_Mics_FB$[iRoom]			= sData;
		case(4):	DSP_Line_FB$[iRoom]			= sData;	
		case(5):	MTRX_Macro_Src_FB$[iRoom]	= sData;	
		case(6):	MTRX_Macro_Dst_FB$[iRoom]	= sData;	
	}                 
}

FUNCTION fUpdateListNumOfItems(INTEGER iRoom, INTEGER iList)
{
	switch(iList)
	{
    	case(1):	MTRX_AdminVSrc_NumOfItems[iRoom]	= Room[iRoom].List[iList].iMaxNumItems;
    	case(2):	MTRX_AdminVDst_NumOfItems[iRoom]	= Room[iRoom].List[iList].iMaxNumItems;
    	case(3):	DSP_Mics_NumOfItems[iRoom]			= Room[iRoom].List[iList].iMaxNumItems;
    	case(4):	DSP_Line_NumOfItems[iRoom]			= Room[iRoom].List[iList].iMaxNumItems;
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  Build data to send


FUNCTION fUpdateListFB(INTEGER iRoom, INTEGER iList, INTEGER iIndex)					//This is for button state feedback
{
	INTEGER i, j;
	STRING 	sTemp[1000];
	    
	if(Room[iRoom].List[iList].iListUsesFB)
	{ 
		sTemp = "{ListButtonFB:";
		if(iIndex && Room[iRoom].List[iList].Item[iIndex].iItemActive)
		{
			makestring(sTemp, "%s%u=%u,;}", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iFB);
		}
		else	
		{
	    	for(iIndex = 1 to Room[iRoom].List[iList].iMaxNumItems)
			{
	      		if(Room[iRoom].List[iList].Item[iIndex].iItemActive)  makestring(sTemp, "%s%u=%u,", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iFB); 	
			}
			sTemp = sTemp + "|;}";
		}
		fSendListFB(iRoom, iList, sTemp);
	}
}

FUNCTION fUpdateListVis(INTEGER iRoom, INTEGER iList, INTEGER iIndex)				
{
	INTEGER i, j;
	STRING 	sTemp[1000];
     
	if(Room[iRoom].List[iList].iListUsesVis)
	{ 
		sTemp = "{ListVisFB:";
		if(iIndex && Room[iRoom].List[iList].Item[iIndex].iItemActive)	makestring(sTemp, "%s%u=%u,;}", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iVis);
		else	
		{
	    	for(iIndex = 1 to Room[iRoom].List[iList].iMaxNumItems)
			{
	      		if(Room[iRoom].List[iList].Item[iIndex].iItemActive)  makestring(sTemp, "%s%u=%u,", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iVis); 	
			}
			sTemp = sTemp + "|;}";
		}
		fSendListFB(iRoom, iList, sTemp);
		if(iList = 1)	fSendListFB(iRoom, 5, sTemp);

	}
}
 
FUNCTION fUpdateListIcon(INTEGER iRoom, INTEGER iList, INTEGER iIndex)
{
	INTEGER i, j;
	STRING 	sTemp[1000];
     
	if(Room[iRoom].List[iList].iListUsesIcon)
	{ 
		sTemp = "{ListIconFB:";
		if(iIndex && Room[iRoom].List[iList].Item[iIndex].iItemActive)	
		{
			makestring(sTemp, "%s%u=%u,;}", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iIcon);
		}
		else	
		{
	    	for(iIndex = 1 to Room[iRoom].List[iList].iMaxNumItems)
			{
	      		if(Room[iRoom].List[iList].Item[iIndex].iItemActive)  makestring(sTemp, "%s%u=%u,", sTemp, iIndex, Room[iRoom].List[iList].Item[iIndex].iIcon); 	
			}
			sTemp = sTemp + "|;}";
		}
		fSendListFB(iRoom, iList, sTemp);
    }
}

FUNCTION fUpdateListText(INTEGER iRoom, INTEGER iList, INTEGER iIndex)
{
	INTEGER i, j;
	STRING 	sTemp[1000];
     
	if(Room[iRoom].List[iList].iListUsesText)
	{ 
		sTemp = "{ListTextFB:";
		if(iIndex && Room[iRoom].List[iList].Item[iIndex].iItemActive)	
		{
			sTemp = sTemp + itoa(iIndex) + "=";
			for(j = 1 to Room[iRoom].List[iList].iNumOfTextColumns)
			{
				makestring(sTemp, "%s%s,", sTemp, Room[iRoom].List[iList].Item[iIndex].sText[j]);
			}
			sTemp = sTemp + "|;}";                       
		}
		else	
		{
	    	for(iIndex = 1 to Room[iRoom].List[iList].iMaxNumItems)
			{
				if(Room[iRoom].List[iList].Item[iIndex].iItemActive)
				{		
					sTemp = sTemp + itoa(iIndex) + "=";
					for(j = 1 to Room[iRoom].List[iList].iNumOfTextColumns)
					{
						makestring(sTemp, "%s%s,", sTemp, Room[iRoom].List[iList].Item[iIndex].sText[j]);
					}
					sTemp = sTemp + "|";
				}
				if(len(sTemp) > 850)
				{
                	sTemp = sTemp + ";}";
					fSendListFB(iRoom, iList, sTemp);
					if(iList = 1)	fSendListFB(iRoom, 5, sTemp);
					sTemp = "{ListTextFB:";
				}
			}
			sTemp = sTemp + ";}";
		}
		if(find("|", sTemp))
		{
			fSendListFB(iRoom, iList, sTemp);
			if(iList = 1)	fSendListFB(iRoom, 5, sTemp);
		}
	}
}
       

FUNCTION fUpdateListAll(INTEGER iRoom, INTEGER iList, INTEGER iIndex)
{
	fUpdateListFB(iRoom, iList, iIndex);
	fUpdateListVis(iRoom, iList, iIndex);
	fUpdateListIcon(iRoom, iList, iIndex);
	fUpdateListText(iRoom, iList, iIndex);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		Configure internal

     
             
FUNCTION fConfigureListVisProcess(INTEGER iRoom, INTEGER iFromList, INTEGER iToList, INTEGER iIndex)
{
	//if an RC src or dst, its visibility should track the state of Sys.iRCState
		 if(Room[iRoom].List[iFromList].Item[iIndex].iIsRCItem)			Room[iRoom].List[iToList].Item[iIndex].iVis	= Sys.iRCState;		 
	//if a virtual src or dst, use its iVLink value as the vis (if theres no VLink, the value is 0... perfect! #futureregret
	else if(Room[iRoom].List[iFromList].Item[iIndex].iIsVirtual)		Room[iRoom].List[iToList].Item[iIndex].iVis	= Room[iRoom].List[iFromList].Item[iIndex].iVLink;		
	//otherwise, fire it up!
	else if(Room[iRoom].List[iFromList].Item[iIndex].iItemActive)		Room[iRoom].List[iToList].Item[iIndex].iVis	= 1;		
	else	;
}

FUNCTION fConfigureListVis(INTEGER iRoom, INTEGER iList, INTEGER iIndex)
{
	//for all lists
	if(iIndex)																fConfigureListVisProcess(iRoom, iList, iList, iIndex);
	else	for(iIndex = 1 to Room[iRoom].List[iList].iMaxNumItems)			fConfigureListVisProcess(iRoom, iList, iList, iIndex);
                
	//if iList=1, also copy that vis data to list[5], up to the max number of items in list[5]
	if(iList = ciList_MTRX_AdminVSrc)				//copies vis to list 5
	{
		if(iIndex)																fConfigureListVisProcess(iRoom, iList, 5, iIndex);
		else	for(iIndex = 1 to Room[iRoom].List[5].iMaxNumItems)				fConfigureListVisProcess(iRoom, iList, 5, iIndex);
	}
}

FUNCTION fConfigureListText(INTEGER iRoom, INTEGER iList, INTEGER iIndex)			//does NOT take iIndex value=0
{
	STRING sTemp[20];
	if(Sys.iRCState)		makestring(sTemp, "%s ", Room[iRoom].sRoomNameShort );
	if(iIndex)
	{
		switch(iList)
		{
			case(1):			
			{						//Admin VSrc list - only uses 1 sText[] field (source name)
				makestring(Room[iRoom].List[iList].Item[iIndex].sText[1], "%s%s", sTemp, Room[iRoom].List[iList].Item[iIndex].sLocalName);//LocalSrc
								//also copy this to list 5 (main vSrc)
				Room[iRoom].List[5].Item[iIndex].sText[1]		= 	Room[iRoom].List[iList].Item[iIndex].sLocalName;//MainSrc
			}
			case(2):
			{
								//Admin vDst list - uses 2 sText[] fields (destination name, routed source name)
				makestring(Room[iRoom].List[iList].Item[iIndex].sText[1], "%s%s", sTemp, 	Room[iRoom].List[iList].Item[iIndex].sLocalName);
				makestring(Room[iRoom].List[iList].Item[iIndex].sText[2], "%s",			 	Room[iRoom].List[iList].Item[iIndex].sRoutedSrc);
			}
			case(5):
			{
				if(iIndex <= Room[iRoom].List[5].iMaxNumItems)
					Room[iRoom].List[iList].Item[iIndex].sText[1]	= 	Room[iRoom].List[iList].Item[iIndex].sLocalName;
			}
		}
	}
}

FUNCTION fSetListFB(INTEGER iRoom, INTEGER iList, INTEGER iSkipIndex, INTEGER iVal)	//iSkipIndex allows skipping over modification of the 'active' source. 0 to ignore
{
	INTEGER i;

	for(i = 1 to Room[iRoom].List[iList].iMaxNumItems)
	{
    	if(i <> iSkipIndex)		Room[iRoom].List[iList].Item[i].iFB	= iVal;
	}
}

FUNCTION fSetListMacroFB(INTEGER iRoom, INTEGER iMacro, INTEGER iSrc)	
{
	INTEGER i;
     
	//Room[iRoom].Macro[iMacro].iState	= iSrc;                   
    switch(iRoom)
	{
    	case(1):
		{
        	MTRX_Macro1_Src_FB[iMacro]	= iSrc; 
		}
		case(2):
		{
        	MTRX_Macro2_Src_FB[iMacro]	= iSrc;
		}
	}		
}

FUNCTION fUpdateCamFB(INTEGER iRoom)
{
	INTEGER i, iFB;
	STRING	sTemp[100];

	sTemp = "{ListButtonFB:";
	for(i = 1 to ciMaxNumCams)
	{
		iFB = 0;
 		if(Room[iRoom].iCamSel = i)		iFB = 1;

		makestring(sTemp, "%s%u=%u,", sTemp, i, iFB);    	
	}

	makestring(sTemp, "%s|;}", sTemp);
	
    CAM_FB$[iRoom]	= sTemp;
}

FUNCTION fUpdateCamVis(INTEGER iRoom)
{
	INTEGER i;
	STRING	sTemp[100];

	sTemp = "{ListVisFB:";
	for(i = 1 to ciMaxNumCams)
	{
    	makestring(sTemp, "%s%u=%u,", sTemp, i, Room[iRoom].Cam[i].iVis);
	}

	makestring(sTemp, "%s|;}", sTemp);
	Cam_FB$[iRoom] = sTemp;
}


                                                                                                                         
//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//

 
FUNCTION fUSBTake(INTEGER iRoom, INTEGER iDstGUID, INTEGER iSrcGUID)
{
	makestring(to_MST_Tx$[iRoom], "{USB_RTE; iGUIDdst=%u: iGUIDsrc=%u|}",
									iDstGUID,
										iSrcGuid	);
}

FUNCTION fMTRXTake(INTEGER iRoom, INTEGER iDstGUID, INTEGER iSrcGUID)						//single routes at a time only
{																					//pass GUIDs to this function

	makestring(to_MST_Tx$[iRoom], "{MTRX_V_RTE; iGUIDdst=%u: iGUIDsrc=%u|}", 
									iDstGUID,     
										iSrcGUID);

}

FUNCTION fUpdateConfMonitorRte(INTEGER iRoom, INTEGER iSrcGUID)
{

	//v1.0.80 - iSrcGUID=0 was made OK by automatically populating MTRX Input[0] in the MTRX CP3 (CP-03)
	//GlobalMST does not reference the iSrcGuid value sent here - only passes it along to the CP3

	fMTRXTake(iRoom, Room[iRoom].List[ciList_MTRX_AdminVDst].Item[ciConfMonLocal].iGUID, iSrcGUID);			
}


//-----------------------------------------------------------------------------------------------------//

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------------------------------//
 
SIGNED_INTEGER_FUNCTION fMTRX_VRte_Clear(INTEGER iRoom, INTEGER iDstIndex)			
{
	INTEGER i;

	if(iDstIndex)
	{
    	fMTRXTake(iRoom, Room[iRoom].List[2].Item[iDstIndex].iGUID, 0);
	}
	else
	{
    	for(i = 1 to ciMaxNumListItems)
		{
        	if(!Room[iRoom].List[2].Item[i].iIsRCItem	&&	Room[iRoom].List[2].Item[i].iItemActive)
			{
            	fMTRXTake(iRoom, Room[iRoom].List[2].Item[i].iGUID, 0);
			}
		}
	}
}

            
FUNCTION fUpdateMacroSrc(INTEGER iRoom, INTEGER iMacro, INTEGER iVSrcLocalID )
{
	INTEGER iDst, iSrcIsUSB, iVDstLocalID;
    
   	//trace("NodeMST - in fUpdateMacroSrc: iRoom=%u, iMacro=%u, iLocalSrcID=%u, iDiscreteMacroMode=%u",
	//			iRoom, iMacro, iVSrcLocalID, Room[iRoom].iDiscreteMacroMode);
    
	//store the source being routed per Page and Subpage, for recall on page flips
    Room[iRoom].iLastSrcSel[Room[iRoom].iUI_Page][Room[iRoom].iUI_Sub]		= Room[iRoom].List[1].Item[iVSrcLocalID].iGUID;
	                                                                     
	switch(Room[iRoom].iDiscreteMacroMode)
	{
		case(0):
		{
        	if(iMacro = 1)										//macro src set #1 is the only one that works when not in discrete_macro_mode
			{
				Room[iRoom].Macro[iMacro].List[1].iState					= iVSrcLocalID;
				fSetListMacroFB(iRoom, iMacro, iVSrcLocalID);
				fUpdateConfMonitorRte(iRoom, Room[iRoom].List[1].Item[iVSrcLocalID].iGUID);
			}
			else
			{
            	trace("NodeMST - attempting to use a Macro Src set other than [1] while discrete_macro_mode is disabled");
			}
		}
		case(1):												//most standard classrooms use this macro route type
		{
			Room[iRoom].Macro[iMacro].List[1].iState						= iVSrcLocalID;                  	//set macro state
			fSetListMacroFB(iRoom, iMacro, iVSrcLocalID);						//set list FB states and send FB updates
			fUpdateConfMonitorRte(iRoom, Room[iRoom].List[1].Item[iVSrcLocalID].iGUID);
                              
			//PGM Audio router
			if(Room[iRoom].Macro[iMacro].iPgmAudio)	
				DSP_PGM_Rte[iRoom] = Room[iRoom].List[1].Item[iVSrcLocalID].iPgmAudio;
             
			//Video route to displays
			for(iDst = 1 to Room[iRoom].Macro[iMacro].List[1].iNumOfObjects)
			{
                iVDstLocalID = Room[iRoom].Macro[iMacro].List[1].iList[iDst];
				
		   		fMTRXTake(iRoom,
					Room[iRoom].List[2].Item[iVDstLocalID].iGUID, 
						Room[iRoom].List[1].Item[iVSrcLocalID].iGUID);
               	
				//USB
				if(Room[iRoom].Macro[iMacro].iUSB)
				{
					//If the source belongs to this room  				 &&  the destination is a USB destination
                	if(!Room[iRoom].List[1].Item[iVSrcLocalID].iIsRCItem  &&  Room[iRoom].List[2].Item[iVDstLocalID].iIsUSB	)
					{
						fUSBTake(iRoom, 
							Room[iRoom].List[2].Item[iVDstLocalID].iGUID, 
								Room[iRoom].List[1].Item[iVSrcLocalID].iGUID);
					}
				}				
			}
		}
	}
} 

FUNCTION fUpdateMacroDst(INTEGER iRoom, INTEGER iMacroDst)
{
	INTEGER i;
	STRING sTemp[200];

	switch(Room[iRoom].iMacroTakeMode)
	{
    	case(0):							//when "Take" button is not used
		{
			if(Room[iRoom].Macro[1].List[1].iState)
			{
            	for(i = 1 to Room[iRoom].Macro[iMacroDst].List[1].iNumOfObjects)
				{
			   		fMTRXTake(iRoom, 
						Room[iRoom].List[ciList_MTRX_AdminVDst].Item[Room[iRoom].Macro[iMacroDst].List[1].iList[i]].iGUID, 
							Room[iRoom].List[ciList_MTRX_AdminVSrc].Item[Room[iRoom].Macro[1].List[1].iState].iGUID);
				}
			}
		}
		case(1):							//when "Take" button IS used
		{
     		Room[iRoom].Macro[iMacroDst].iFB	= !Room[iRoom].Macro[iMacroDst].iFB;
			makestring(sTemp, "{ListButtonFB;%u=%u,|", iMacroDst, Room[iRoom].Macro[iMacroDst].iFB);
			fSendListFB(iRoom, 6, sTemp); 	
		}
	}
}
 

FUNCTION fConfigureListTextRmNums(INTEGER iRoom, INTEGER iList, INTEGER iState)
{
	INTEGER iIndex;
	STRING	sThisRoom[20], sOtherRoom[20];

	if(Sys.iRCState)			//if rooms are combined, create the room number string as "nnn ", else if rooms separate, then ""
	{
		makestring(sThisRoom, "%s ", Room[iRoom].sRoomNameShort);
		makestring(sOtherRoom, "%s ", Room[fOtherRoom(iRoom)].sRoomNameShort);
    }

	for(iIndex = 1 to ciMaxNumListItems)
	{
       	if(Room[iRoom].List[iList].Item[iIndex].iItemActive)
		{
			if(Room[iRoom].List[iList].Item[iIndex].iIsRCItem)
				makestring(Room[iRoom].List[iList].Item[iIndex].sText[1], "%s%s", sOtherRoom, Room[iRoom].List[iList].Item[iIndex].sLocalName);
			else 
				makestring(Room[iRoom].List[iList].Item[iIndex].sText[1], "%s%s", sThisRoom, Room[iRoom].List[iList].Item[iIndex].sLocalName);
		}
	}
}

FUNCTION fUpdateRC(INTEGER iType)
{
	INTEGER i, iRoom, iList, iIndex, v[2];
                      
	switch(iType)
	{
        case(1):						//combine!
		{	
        	//VTC VLinks
			for(iRoom = 1 to 2)
			{
				v[iRoom] = Room[iRoom].List[1].Item[ciLocalSrcID_VTC1].iVLink;
			}

			if(Room[2].iVTCAllocation && !Room[1].iVTCAllocation)						//if there's a VTC allocated to room 2, and not to room 1, then room 1 receives room 2's VTC info
			{
				fCopyIO(2,  ciLocalSrcID_VTC1,	 1,  ciLocalSrcID_VTC1,  1);
				fCopyIO(2,  ciLocalSrcID_VTC2,   1,  ciLocalSrcID_VTC2,  1);

				Room[1].iVTCAllocation = Room[2].iVTCAllocation;
			}
			else																		//all other cases, pass rm 1 to rm 2
			{
				fCopyIO(1,  ciLocalSrcID_VTC1, 	 2,  ciLocalSrcID_VTC1,  1);
				fCopyIO(1,  ciLocalSrcID_VTC2,   2,  ciLocalSrcID_VTC1,  1);

				Room[2].iVTCAllocation = Room[1].iVTCAllocation;
			}
			
			//Cam Vis and FB
			for(iRoom = 1 to 2)
			{
				fUpdateCamFB(iRoom);
            	for(i = 4 to 6)
				{
					Room[iRoom].Cam[i].iVis = Room[iRoom].Cam[i].iCamActive;
				}
				fUpdateCamVis(iRoom);
			}
		}
        case(0):       					//uncombine
		{
			for(iRoom = 1 to 2)
            	for(i = 4 to 6)        	Room[iRoom].List[1].Item[i].iVLink  = 0;

			//Cam Vis and FB
			for(iRoom = 1 to 2)
			{
				Room[iRoom].iCamSel	= 1;
				fUpdateCamFB(iRoom);
            	for(i = 4 to 6)			Room[iRoom].Cam[i].iVis = 0;
				fUpdateCamVis(iRoom);
			}
		}		
    }                                                                     
	
	for(iRoom = 1 to 2)		
	{
		for(iList = 1 to 2)
		{
			for(iIndex = 1 to ciMaxNumListItems)
            {
				if(Room[iRoom].List[iList].Item[iIndex].iIsRCItem  ||  Room[iRoom].List[iList].Item[iIndex].iIsVirtual)
				{
					fConfigureListVis(iRoom, iList, iIndex);
					fUpdateListVis(iRoom, iList, iIndex);
				}
			}
			//update list text to include (or exclude) room numbers
			fConfigureListTextRmNums(iRoom, iList, Sys.iRCState);
			fUpdateListText(iRoom, iList, 0);
        }
	}	
}
  
                                                                                                                         
//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//

FUNCTION fProcessFinalize(INTEGER iRoom, INTEGER iList)
{
	INTEGER iOtherRoom, i, j;
	
	fUpdateListNumOfItems(iRoom, iList);

	switch(iList)
	{
    	case(1):												//MTRX_VSRC
		{
			/*
			[1-3]   	local PC, laptop, wireless
			[4-6]   	virtual aux, vtc1, vtc2
			[7-9]	  	other room PC, laptop, wireless
			[21-23] 	cams
			[24-26] 	cams rc
			[31-40] 	other sources
			[41-50] 	other sources RC
            */
            
			//[1-3] configure  PC, Laptop, and Mersive
			for(i = 1 to 3)     
			{
				Room[iRoom].List[iList].Item[i].iVis					= 1;		//set vis on local presentation sources
				fConfigureListText(iRoom, iList, i);
            	
				//[7-9] RC
				if(Sys.iIsRCPair)
				{
					Room[iRoom].List[1].Item[i+6].iIsRCItem		= 1;
					fCopyIO(iRoom, i, fOtherRoom(iRoom), i+6, iList);						//copy local presentation sources to other room
					fConfigureListText(fOtherRoom(iRoom), iList, i+6);
				}
			}

            //[4-6] virtual sources
			for(i = 1 to 3)
				Room[iRoom].List[iList].Item[i+3].iVis	= Room[iRoom].List[iList].Item[i+3].iVLink;			// set iVis for Virtuals

			//[10-20]		
			for(i = 10 to 20)
			{
            	if(Room[iRoom].List[iList].Item[i].iItemActive)
				{
	    			Room[iRoom].List[iList].Item[i].iVis				= 1;		//these will probably be the 5th and 6th floor rooms' station laptop inputs
					fConfigureListText(iRoom, iList, i);
				}
			}
			
			//[21-23] cams
			for(i = 1 to 3)	
            {	
				if(Room[iRoom].List[iList].Item[i+20].iItemActive)
				{
	    			Room[iRoom].List[iList].Item[i+20].iVis				= 1;
					fConfigureListText(iRoom, iList, i+20);
        			
					//[24-26] RC
					if(Sys.iIsRCPair)
					{
						Room[fOtherRoom(iRoom)].List[1].Item[i+23].iIsRCItem		= 1;       	
						fCopyIO(iRoom, i+20, fOtherRoom(iRoom), i+23, iList);	
						fConfigureListText(fOtherRoom(iRoom), iList, i+23);
					}
				}
			}

			//[31-40] other sources
			for(i = 1 to 10)	
            { 
				if(Room[iRoom].List[iList].Item[i+30].iItemActive)
				{
	    			Room[iRoom].List[iList].Item[i+30].iVis				= 1;
					fConfigureListText(iRoom, iList, i+30);
					
					//[41-50] RC		
                    if(Sys.iIsRCPair)
					{
						Room[fOtherRoom(iRoom)].List[1].Item[i+23].iIsRCItem		= 1;       	
						fCopyIO(iRoom, i+30, fOtherRoom(iRoom), i+40, iList);					
						fConfigureListText(fOtherRoom(iRoom), iList, i+40);
					}
				}
			}
			
			//[1-50] set false iVis states
            for(i = 1 to 50)			
			{
          		if(!Room[iRoom].List[iList].Item[i].iItemActive)
              		Room[iRoom].List[iList].Item[i].iVis				= 0;  	
			}			
		}

    	case(2):			//MTRX_VDST
		{
			if(Sys.iIsRCPair)			//if this is a room-combine system, then limit the number of displays, etc, to copy from one room to the other
			{
				/*
				as of v1.0.80, local destination index table as follows:
				[1-20] 		- Displays	(this room)
				[21-40] 	- Displays 	(other room)
				[41]		- USB Video (this room Mediaport)
				[42]		- USB Video (other room Mediaport)
				[43]		- VTC Cam Tx
				[44]		- VTC Content Tx
				[49]		- ConfMon   (this room)
				[50]		- ConfMon	(that room)
				*/
				
				//[1-20] displays
				for(i = 1 to 20)
				{	
	            	if(Room[iRoom].List[iList].Item[i].iItemActive)
					{
						Room[iRoom].List[iList].Item[i].iVis					= 1;	
						fConfigureListText(iRoom, iList, i);

						//[21-40] RC
						fCopyIO(iRoom, i, fOtherRoom(iRoom), i+20, iList);				
						fConfigureListText(fOtherRoom(iRoom), iList, i+20);
					}
					//[21-40] RC iIsRCItem
					Room[iRoom].List[iList].Item[i+20].iIsRCItem				= 1;
				}
				
				//[41] USB Vid
				if(Room[iRoom].List[iList].Item[41].iItemActive)								
				{
					Room[iRoom].List[iList].Item[41].iVis						= 1;
					fConfigureListText(iRoom, iList, 41);
				
					//[42] RC
					fCopyIO(iRoom, 41, fOtherRoom(iRoom), 42, iList);							
					fConfigureListText(fOtherRoom(iRoom), iList, 42);
				}
				Room[fOtherRoom(iRoom)].List[iList].Item[42].iIsRCItem			= 1;

				
				//[49] Panel Preview
				if(Room[iRoom].List[iList].Item[49].iItemActive)
				{
					Room[iRoom].List[iList].Item[49].iVis						= 1;		
					fConfigureListText(iRoom, iList, 49);

					//[50] RC
					fCopyIO(iRoom, 49, fOtherRoom(iRoom), 50, iList);							
					fConfigureListText(fOtherRoom(iRoom), iList, 50);
				}
				Room[fOtherRoom(iRoom)].List[iList].Item[50].iIsRCItem			= 1;

			}
			else						//if this is a single room (not RC), then open up the entire list of 50 destinations to whatever is assigned
			{
				//[1-50]
            	for(i = 1 to ciMaxNumListItems)
				{
					//config all active items
					if(Room[iRoom].List[iList].Item[i].iItemActive)
					{
						Room[iRoom].List[iList].Item[i].iVis					= 1;
						fConfigureListText(iRoom, iList, i);
					}
					//else set the iVis low and fugeddabaddit()
					else	Room[iRoom].List[iList].Item[i].iVis				= 0;
				}
			}
		}
         
		//Macros - just using this as a signal for the end of the data load
		case(14):
		{
      		if(iRoom = 2) wait(1000)
			{
           		fUpdateRC(Sys.iRCState);
			}  	
		}
	}

	fConfigureListVis(iRoom, iList, 0);
	fUpdateListAll(iRoom, iList, 0);

	fConfigureListVis(fOtherRoom(iRoom), iList, 0);
	fUpdateListAll(fOtherRoom(iRoom), iList, 0);
}
  

FUNCTION fProcessVRoute(INTEGER iRoom, INTEGER iLocalIndex, STRING sTempLine)
{
	//{MTRX_RTE;localID=%u: src_guid=%u,src_name=%s,|}
	STRING 	sTempData[500],
			sTempGUID[30],
			sTempSrc[100];
                              
	//{MTRX_V_RTE; LocalID=2:src_guid=157,src_name=222 STAGE PODIUM HDMI IN 1,|}       example
	sTempData	= sTempLine; 
	sTempGUID	= remove(",", sTempData);
	sTempSrc	= left(sTempData, find(",", sTempData) - 1);
	sTrash 		= remove("src_name=", sTempSrc);

	//local room
	Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iLocalIndex].iRoutedSrc	= atoi(sTempGUID);
	Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iLocalIndex].sRoutedSrc	= sTempSrc;
	fConfigureListText(iRoom, ciList_MTRX_AdminVDst, iLocalIndex);
	fUpdateListText(iRoom, ciList_MTRX_AdminVDst, iLocalIndex);    

	//if RC dst, other room too
	if(Sys.iRCState)
	{
		if(iLocalIndex >= 1 && iLocalIndex <= 20)				//local room destinations
		{
			Room[fOtherRoom(iRoom)].List[ciList_MTRX_AdminVDst].Item[iLocalIndex+20].iRoutedSrc	= atoi(sTempGUID);
			Room[fOtherRoom(iRoom)].List[ciList_MTRX_AdminVDst].Item[iLocalIndex+20].sRoutedSrc	= sTempSrc;
			fConfigureListText(fOtherRoom(iRoom), ciList_MTRX_AdminVDst, iLocalIndex);
	    	fUpdateListText(fOtherRoom(iRoom), ciList_MTRX_AdminVDst, iLocalIndex);
		}	
	}
}
                       

INTEGER_FUNCTION fProcessMacroObject(INTEGER iRoom, INTEGER iMacro, STRING sData)
{
	INTEGER iInv;
    //if a macro object has a "-", it indicates that the object goes in the list of inverted behaviors (List[2]), else its just in List[1]
	if(find("-", sData))	iInv														= 1;
	//if it contains "*", this indicates that it is the primary object of the list
	if(find("*", sData))	Room[iRoom].Macro[iMacro].List[1+iInv].iPrimaryObject		= atoi(sData);
	if(atoi(sData)  ||  find("0", sData))
	{
		Room[iRoom].Macro[iMacro].List[1+iInv].iNumOfObjects  							= Room[iRoom].Macro[iMacro].List[1+iInv].iNumOfObjects + 1;
		Room[iRoom].Macro[iMacro].List[1+iInv].iList[ Room[iRoom].Macro[iMacro].List[1+iInv].iNumOfObjects ]					= atoi(sData);		
	}
	else   	return(0);	//if there's no number, discard
}

INTEGER_FUNCTION fProcessMacro(INTEGER iRoom, INTEGER iMacro, STRING sLine)
{	
	//{MACRO_14; macro_id=%u:  <-- already taken out 
	//name=sss, pgm_audio=1, usb=1, list=(1,2,3,*4,-9),|}
    //
	INTEGER i;
	STRING sTemp[200], sData[300], sTempKV[300], sTempKey[100];
	sData = sLine;
                       
	Room[iRoom].Macro[iMacro].iItemActive	= 1;
    while(find("=", sData))
	{
		sTempKey = remove("=", sData);
        
			 if(findnocase("name", sTempKey))
		{
		   	Room[iRoom].Macro[iMacro].sName			= left(sData, find(",", sData) - 1);
			sTrash = remove(",", sData);
		}
		else if(findnocase("usb", sTempKey))		Room[iRoom].Macro[iMacro].iUSB			= atoi(sData);
		else if(findnocase("pgm_audio", sTempKey))	Room[iRoom].Macro[iMacro].iPgmAudio		= atoi(sData);
		else if(findnocase("list", sTempKey))					
		{
			sTemp = remove(")", sData);
			while(find(",", sTemp))
	        	fProcessMacroObject(iRoom, iMacro, remove(",", sTemp));
			if(len(sTemp) > 1) 
	        	fProcessMacroObject(iRoom, iMacro, sTemp);
		}
		else	
		{
			trace("NodeMST - fProcessMacro - error parsing macro, %s", sLine);
		}
	}
}


FUNCTION fProcessLine(INTEGER iRoom, INTEGER iList, INTEGER iIndex, STRING sTemp)
{
	INTEGER i,
			iErr,
			iCam,
			iDisplay;
	STRING  sTempKey[50],
			sTempValue[100],
			sTempPair[151],
			sTempLine[1000];

	sTempLine	= sTemp;
 
   
	Room[iRoom].List[iList].Item[iIndex].iItemActive	= 1;
	Room[iRoom].List[iList].iMaxNumItems				= max(iIndex, Room[iRoom].List[iList].iMaxNumItems);
    	
	//item details
	while(find(",", sTempLine))
	{
   		sTempPair 	= remove(",", sTempLine);
		sTempKey	= remove("=", sTempPair);
		sTempValue	= left(sTempPair, len(sTempPair) - 1);
    
   			 if(findnocase("global_name", sTempKey))		Room[iRoom].List[iList].Item[iIndex].sGlobalName				= sTempValue;
   		else if(findnocase("local_name", sTempKey))			Room[iRoom].List[iList].Item[iIndex].sLocalName					= sTempValue;
        else if(findnocase("guid", sTempKey))				Room[iRoom].List[iList].Item[iIndex].iGUID						= atoi(sTempValue);	
        else if(findnocase("function", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iFunctionID				= atoi(sTempValue);
        else if(findnocase("sys_preset", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iSysPreset					= atoi(sTempValue);
        else if(findnocase("is_camera", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iIsCamera					= atoi(sTempValue);
		else if(findnocase("cam_localid", sTempKey))		Room[iRoom].List[iList].Item[iIndex].iCamLocalID				= atoi(sTempValue);
		else if(findnocase("cam_global", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iCamGUID					= atoi(sTempValue);

        else if(findnocase("is_display", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iIsDisplay					= atoi(sTempValue);
		else if(findnocase("display_localid", sTempKey))	Room[iRoom].List[iList].Item[iIndex].iDisplayLocalID			= atoi(sTempValue);
		else if(findnocase("display_global", sTempKey))		Room[iRoom].List[iList].Item[iIndex].iDisplayGUID				= atoi(sTempValue);
        else if(findnocase("virtual", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iIsVirtual					= atoi(sTempValue);
		else if(findnocase("usb_mac", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iIsUSB						= 1;
		else if(findnocase("pgm_audio", sTempKey))			Room[iRoom].List[iList].Item[iIndex].iPGMAudio					= atoi(sTempValue);

        else 
		{
        	trace("NodeMST - fProcessLine - didn't catch key:   GUID=%u, %s%s", iIndex, sTempKey, sTempValue);
			iErr = 1;
		}
	}
    
	if(Room[iRoom].List[iList].Item[iIndex].iGUID)  		Room[iRoom].List[iList].iGlobalToLocal[Room[iRoom].List[iList].Item[iIndex].iGUID] 	= iIndex; 	
    
	if(Room[iRoom].List[iList].Item[iIndex].iIsCamera)				//if the src is a camera
	{

		iCam 														= Room[iRoom].List[iList].Item[iIndex].iCamLocalID;

		Room[iRoom].Cam[iCam].iCamGUID								= Room[iRoom].List[iList].Item[iIndex].iCamGUID;
    	Room[iRoom].Cam[iCam].iCamActive							= 1;
		Room[iRoom].Cam[iCam].iVis									= 1;
		Room[iRoom].Cam[iCam].iVSrcLocalID							= iIndex;
		Room[iRoom].Cam[iCam].iVSrcGUID								= Room[iRoom].List[iList].Item[iIndex].iGUID;
		Room[iRoom].Cam[iCam].sGlobalName							= Room[iRoom].List[iList].Item[iIndex].sGlobalName;
		Room[iRoom].Cam[iCam].sLocalName							= Room[iRoom].List[iList].Item[iIndex].sLocalName;

		Room[iRoom].Cam[iCam].iSysPreset							= Room[iRoom].List[iList].Item[iIndex].iSysPreset;

		makestring(CAM_FB$[iRoom], "{ListVisFB:%u=1,|; ListTextFB:%u=%s,|;}", iCam, iCam, Room[iRoom].Cam[iCam].sGlobalName);	
    
        if(Sys.iIsRCPair)
		{                      
    		Room[fOtherRoom(iRoom)].Cam[iCam+3].iCamActive				= 1;
	       	makestring(CAM_FB$[fOtherRoom(iRoom)], "{ListTextFB:%u=%s,|;}", iCam+3, Room[iRoom].Cam[iCam].sGlobalName);
	
			if(Sys.iRCState)
			{
				Room[fOtherRoom(iRoom)].Cam[iCam+3].iVis						= 1;
	        	makestring(CAM_FB$[fOtherRoom(iRoom)], "{ListVisFB:%u=1,|;}", iCam+3);
			}
			Room[fOtherRoom(iRoom)].Cam[iCam+3].iCamGUID				= Room[iRoom].Cam[iCam].iCamGUID;
			Room[fOtherRoom(iRoom)].Cam[iCam+3].iVSrcGUID				= Room[iRoom].Cam[iCam].iVSrcGUID;
		}
	}
	else if(Room[iRoom].List[iList].Item[iIndex].iIsDisplay)		//if the dst is a display
	{
		
    	iDisplay															= Room[iRoom].List[iList].Item[iIndex].iDisplayLocalID;
		Room[iRoom].Display[iDisplay].iDisplayGUID							= Room[iRoom].List[iList].Item[iIndex].iDisplayGUID;
    	Room[iRoom].Display[iDisplay].iDisplayActive						= 1;
		Room[iRoom].Display[iDisplay].iVis									= 1;
		Room[iRoom].Display[iDisplay].iVDstLocalID							= iIndex;
		Room[iRoom].Display[iDisplay].iVDstGUID								= Room[iRoom].List[iList].Item[iIndex].iGUID;
		Room[iRoom].Display[iDisplay].sGlobalName							= Room[iRoom].List[iList].Item[iIndex].sGlobalName;
		Room[iRoom].Display[iDisplay].sLocalName							= Room[iRoom].List[iList].Item[iIndex].sLocalName;
		
		Room[iRoom].Display[iDisplay].iSysPreset							= Room[iRoom].List[iList].Item[iIndex].iSysPreset;

		makestring(Display_FB$[iRoom], "{ListVisFB:%u=1,|; ListTextFB:%u=%s,|;}", iDisplay, iDisplay, Room[iRoom].Display[iDisplay].sGlobalName);	
          
        ///
		if(Sys.iIsRCPair)
		{                                                      
	    	Room[fOtherRoom(iRoom)].Display[iDisplay+(ciMaxNumDisplays/2)].iDisplayActive				= 1;
	
			makestring(Display_FB$[fOtherRoom(iRoom)], "{ListTextFB:%u=%s,|;}", iDisplay+(ciMaxNumDisplays/2), Room[iRoom].Display[iDisplay].sGlobalName);
	
			if(Sys.iRCState)
			{
				Room[fOtherRoom(iRoom)].Display[iDisplay+(ciMaxNumDisplays/2)].iVis						= 1;
	        	makestring(Display_FB$[fOtherRoom(iRoom)], "{ListVisFB:%u=1,|;}", iDisplay+(ciMaxNumDisplays/2));
			}
			Room[fOtherRoom(iRoom)].Display[iDisplay+(ciMaxNumDisplays/2)].iDisplayGUID				= Room[iRoom].Display[iDisplay].iDisplayGUID;
			Room[fOtherRoom(iRoom)].Display[iDisplay+(ciMaxNumDisplays/2)].iVDstGUID				= Room[iRoom].Display[iDisplay].iVDstGUID;
		}
	}
}

FUNCTION fProcessRooms(INTEGER iRoom, INTEGER iGlobalRoomNum, STRING sTempLine)
{
	STRING	sData[1000], sTempKV[100], sTempKey[100];

	sData = sTempLine;

	if(find("=", sData))
	{
		Room[iRoom].iRoomActive		= 1;
		Room[iRoom].iRoomGUID		= iGlobalRoomNum;
	}
	if(iRoom = 2  &&  Room[iRoom].iRoomGUID)	Sys.iIsRCPair	= 1;

	while(find(",", sData))
	{
		sTempKV = remove(",", sData);
		sTempKey = remove("=", sTempKV);
		 	 if(findnocase("room_name", sTempKey))				Room[iRoom].sRoomName			= ST.StringTrim(left(sTempKV, len(sTempKV) -1 )); //fTrimWhitespace(sTempKV);
		else if(findnocase("room_num", sTempKey))				Room[iRoom].iBldgRoomNum		= atoi(sTempKV);
		else if(findnocase("discrete_macro_mode", sTempKey))	Room[iRoom].iDiscreteMacroMode	= atoi(sTempKV);
		else if(findnocase("macro_take_mode", sTempKey))		Room[iRoom].iMacroTakeMode		= atoi(sTempKV);
		else if(findnocase("use_src_list_mode", sTempKey))		Room[iRoom].iUseSrcListMode		= atoi(sTempKV);
	} 
	RoomName$_Out[iRoom]			= Room[iRoom].sRoomName;
	makestring(Room[iRoom].sRoomNameShort, "%u", Room[iRoom].iBldgRoomNum);

}

FUNCTION fProcessVLink(INTEGER iType, INTEGER iRoom, INTEGER iLocalIndex, STRING sTempLine)
{
	INTEGER i, iList, iVLink, iLocalID, iOldGUID;
    STRING	sData[200];
                        

	trace("in fProcessVLink - iRoom = %u, iLocalIndex = %u, sData = %s", iRoom, iLocalIndex, sTempLine);
	sData	= sTempLine;
	iVLink	= atoi(sData);
	sTrash 	= remove(",", sData);
	                    
	switch(iType)
	{
		case(15):	iList = 1;		//VSrc
		case(16):	iList = 2;		//VDst
		case(17):	iList = 3;
		case(18):	iList = 4;
	}
   	
	if(Room[iRoom].List[iList].Item[iLocalIndex].iIsVirtual)
	{
		iOldGUID = Room[iRoom].List[iList].Item[iLocalIndex].iVLink;

		//assign values
		Room[iRoom].List[iList].Item[iLocalIndex].iVLink		= iVLink;
		Room[iRoom].List[iList].Item[iLocalIndex].iGUID			= iVLink;
		Room[iRoom].List[iList].Item[iLocalIndex].sGlobalName	= left(sData, find("|", sData) - 1);
        Room[iRoom].List[iList].iGlobalToLocal[iVLink] 			= iLocalIndex;
                            
		//set list item text
		fConfigureListText(iRoom, iList, iLocalIndex);
		fUpdateListText (iRoom, iList, iLocalIndex);
		//set list item vis
        fConfigureListVis(iRoom, iList, iLocalIndex);
		fUpdateListVis(iRoom, iList, iLocalIndex);

		//check for existing local routes, and update if needed
		if(iOldGUID && iOldGUID <> iVLink)			
		{
			for(i = 1 to ciMaxNumListItems)
			{
          		if(Room[iRoom].List[ciList_MTRX_AdminVDst].Item[i].iRoutedSrc	= iOldGUID)
				{
	            	fMTRXTake(iRoom, Room[iRoom].List[ciList_MTRX_AdminVDst].Item[i].iGUID, iVLink);
				}
			}
		}
	}
	else
	{
    	trace("NodeMST - in fProcessVLink - attempting to change the GUID of a list item that is not virtual, room=%u, list=%u, item=%u", iRoom, iList, iLocalIndex);
	}
}

FUNCTION fProcessData(INTEGER iRoom, STRING sTempInitData)
{
	INTEGER i, 
			j,
			iType, 
			iLocalIndex;
	
	STRING 	sTempData[1000], 
			sTempHeader[100], 
			sTempLocalID[20], 
			sTempLine[300];

	sTempData 	= sTempInitData;				//"{MTRX_VSRC_01; LOCALID=%u: GUID=%u, friendly_name=%s, function_id=%u, is_virtual=%u, |} }"
	
	sTempHeader = remove(";", sTempData);		//"{MTRX_VSRC_01;"

	iType = atoi(sTempHeader);

	while(find("|", sTempData))
	{
    	sTempLine 		= remove("|", sTempData);	//"LOCALID=%u: GUID=%u, friendly_name=%s, function_id=%u, is_virtual=%u, |"
		if(find("COMPLETE", sTempLine))		fProcessFinalize(iRoom, iType);
        else
		{
			//can i delete this line now that MACRO uses the regular file loader module?
			if(find(";", sTempLine))	sTrash = remove(";", sTempLine);
			iLocalIndex		= atoi(remove(":", sTempLine));

			if(iLocalIndex)
			{
					 if(iType <= 4)		fProcessLine(iRoom, iType, iLocalIndex, sTempLine);
				else if(iType = 10)		fProcessVRoute(iRoom, iLocalIndex, sTempLine);
				else if(iType = 14)		fProcessMacro(iRoom, iLocalIndex, sTempLine);
				else if(iType = 13)		fProcessRooms(iRoom, iLocalIndex, sTempLine);
				else if(iType = 15)		fProcessVLink(iType, iRoom, iLocalIndex, sTempLine);	//send the type in case we need to also do VDST(16), ASRC(17), and ADST(18)
				else trace("NodeMST - fProcessData - didn't catch iLocalIndex");
			}
			else			trace("NodeMST - fProcessData - iLocalIndex=0.    %s iLocalID=%u;%s", sTempHeader, iLocalIndex, sTempLine); 
		}
	}	
}

  
//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//
  

FUNCTION fDisplayPower(INTEGER iRoom, INTEGER iIndex, INTEGER iState)
{
	INTEGER i;

	if(!iIndex)													//set all displays to nn power
	{
		for(i = 1 to ciMaxNumDisplays / 2)
		{
			if(Room[iRoom].Display[i].iDisplayActive)
			{
				Room[iRoom].Display[i].iDisplayPowerState = iState;
				makestring(to_MST_Tx$[iRoom], "{DPLY_CMD;guid=%u,power=%u,|;}", Room[iRoom].Display[i].iDisplayGUID, iState);
				delay(5); 
			}
		}
	}
	else														//set one display to nn power
	{
  		if(Room[iRoom].Display[iIndex].iDisplayActive)
		{
			Room[iRoom].Display[iIndex].iDisplayPowerState = iState;
			makestring(to_MST_Tx$[iRoom], "{DPLY_CMD;guid=%u,power=%u,|;}", Room[iRoom].Display[iIndex].iDisplayGUID, iState);
			delay(5);
		} 	
	}
}
  
FUNCTION fCamCmdSend(INTEGER iRoom, INTEGER iGUID, STRING sCmd)
{
	if(!iGUID)	iGUID = Room[iRoom].Cam[Room[iRoom].iCamSel].iCamGUID;
	makestring(to_MST_Tx$[iRoom], "{CAM_CTRL; guid=%u: cmd=%s,|;}", iGUID, sCmd);
}

FUNCTION fCamPower(INTEGER iRoom, INTEGER iIndex, INTEGER iState)
{

	//as of v1.0.80, i removed all function calls for fCamPower because Sony cam do not use power / standby states. Always On.
	//I may re-implement this plumbing just for recalling "unused" and "default" presets
    if(iIndex)
	{
  		if(Room[iRoom].Cam[iIndex].iCamActive)
		{
			Room[iRoom].Cam[iIndex].iCamPowerState = iState;
			if(iState)		fCamCmdSend(iRoom, Room[iRoom].Cam[iIndex].iCamGUID, "power_on"); 
			else			fCamCmdSend(iRoom, Room[iRoom].Cam[iIndex].iCamGUID, "power_off"); 
		} 	    	
	}
	
	else													//set all Cams to nn power
	{
		for(iIndex = 1 to 3)
		{
			if(Room[iRoom].Cam[iIndex].iCamActive)
			{
				Room[iRoom].Cam[iIndex].iCamPowerState = iState;
				if(iState)		fCamCmdSend(iRoom, Room[iRoom].Cam[iIndex].iCamGUID, "power_on"); 
				else			fCamCmdSend(iRoom, Room[iRoom].Cam[iIndex].iCamGUID, "power_off"); 
			}
		}
	}
}

    
FUNCTION fSystemPower(INTEGER iRoom, INTEGER iState)
{
	SIGNED_INTEGER siErr;

	fDisplayPower(iRoom, 0, iState);
	//fCamPower(iRoom, 0, iState);
	
	if(!iState)
	{
		siErr =	fMTRX_VRte_Clear(iRoom, 0);
		fUpdateConfMonitorRte(iRoom, Room[iRoom].List[1].Item[ciSourcePC].iGUID);
	}
	else
	{
    	fUpdateMacroSrc(iRoom, 3, ciSourcePC);
	}
}


//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//

FUNCTION fUpdateRC_State_FB(INTEGER iState)
{
	INTEGER i;

	for(i = 1 to 2)
	{
    	if(iState)
		{
        	RC_Off_FB[i] 	= 0;
			RC_On_FB[i] 	= 1;
		}
		else
		{
        	RC_On_FB[i] 	= 0;
			RC_Off_FB[i] 	= 1;
		}
	}
}  
  
FUNCTION fUpdateRC_Enable_FB(INTEGER iState)
{
	INTEGER i;

	for(i = 1 to 2)
	{
		if(iState)
		{
		   	PartSense_Disable_FB[i] = 0;
			PartSense_Enable_FB[i] = 1;
        }
        else
		{
    		PartSense_Enable_FB[i] = 0;
			PartSense_Disable_FB[i] = 1;
		}
	}
}  

 
//------------------------------------------------------------------------------------------------------//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

    
PUSH RC_On
{
	INTEGER i, j;
	
	Sys.iRCState	= 1;
	fUpdateRC_State_FB(Sys.iRCState);
	fUpdateRC(Sys.iRCState);	
}

PUSH RC_Off
{
	INTEGER i, j;
	
	Sys.iRCState	= 0;
	fUpdateRC_State_FB(Sys.iRCState);
	fUpdateRC(Sys.iRCState);
}

PUSH RC_Tog
{
	INTEGER i, j;
	
	Sys.iRCState	= !Sys.iRCState;
	fUpdateRC_State_FB(Sys.iRCState);
	fUpdateRC(Sys.iRCState);
}

CHANGE PartSenseSignal
{
	INTEGER i;

	if(Sys.iPartitionEnabled)
	{
    	Sys.iRCState = !PartSenseSignal[1];
	}
}

PUSH PartSense_Enable
{
	INTEGER i;
	Sys.iPartitionEnabled = 1;

	fUpdateRC_Enable_FB(Sys.iPartitionEnabled);

	if(!PartSenseSignal[1] <> Sys.iRCState)					//if we just re-enabled the part sensor, and the current RC state differs from the !part sensor state, update all RC settings
	{
    	Sys.iRCState = PartSenseSignal[1];
		fUpdateRC_State_FB(Sys.iRCState);
		fUpdateRC(Sys.iRCState);
	}
}

PUSH PartSense_Disable
{
	INTEGER i;
	Sys.iPartitionEnabled = 0;

	fUpdateRC_Enable_FB(Sys.iPartitionEnabled);
}


PUSH Sys_PowerOn
{
	INTEGER iRoom, j;
	iRoom = getlastmodifiedarrayindex();

	pulse(10, Sys_PowerOn_Go[iRoom]);
	Room[iRoom].iSysPowerState	= 1;
	fSystemPower(iRoom, Room[iRoom].iSysPowerState);
     
	if(Sys.iRCState)	
	{
		pulse(10, Sys_PowerOn_Go[fOtherRoom(iRoom)]);
		Room[fOtherRoom(iRoom)].iSysPowerState	= 1;
		fSystemPower(fOtherRoom(iRoom), Room[fOtherRoom(iRoom)].iSysPowerState);
	}

	//default to the PC source     
   	//fUpdateMacroSrc(iRoom, j, ciSourcePC);
}

PUSH Sys_PowerOff
{
	INTEGER i;
	i = getlastmodifiedarrayindex();

	pulse(10, Sys_PowerOff_Go[i]);
	Room[i].iSysPowerState	= 0;
	fSystemPower(i, Room[i].iSysPowerState);
                    
	if(Sys.iRCState)
	{
		pulse(10, Sys_PowerOff_Go[fOtherRoom(i)]);
		Room[fOtherRoom(i)].iSysPowerState	= 0;
		fSystemPower(fOtherRoom(i), Room[fOtherRoom(i)].iSysPowerState);
	}
}

//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//
 

CHANGE Sys_Preset
{
	INTEGER iRoom, 
			iSysPreset,
			i;

	iRoom = getlastmodifiedarrayindex();
    iSysPreset = Sys_Preset[iRoom];
     
	if(iSysPreset)	//value 0 = unused, 10 = all off
	{
    	for(i = 1 to ciMaxNumDisplays)
		{
			if(Room[iRoom].Display[i].iDisplayActive)
			{
            	if(Room[iRoom].Display[i].iSysPreset = iSysPreset  ||  Room[iRoom].Display[i].iSysPreset = 9)   //preset 9 = universal device (applies to all presets)
				{
                	fDisplayPower(iRoom, i, 1);
				}
				else  																							//10 = off, btw
				{
                	fDisplayPower(iRoom, i, 0);
				}
			}
		}
	}

	//audio routes
	//
}


PUSH MTRX_Take 
{
	INTEGER iDst, iRoom, iSrc;
	iRoom = getlastmodifiedarrayindex();

    iSrc = Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected;
	if(fGetNumItemsSelected(iRoom, ciList_MTRX_AdminVDst))
	{
    	for(iDst = 1 to Room[iRoom].List[ciList_MTRX_AdminVDst].iMaxNumItems)
		{
			if(Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iDst].iFB  &&  Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iDst].iItemActive)
			{
				fMTRXTake(iRoom, 
							Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iDst].iGUID, 
								Room[iRoom].List[ciList_MTRX_AdminVSrc].Item[iSrc].iGUID);
			}
		}
	}
}

PUSH MTRX_Clear
{
	INTEGER iRoom;
	iRoom = getlastmodifiedarrayindex();

	fSetListFB(iRoom, ciList_MTRX_AdminVSrc, 0, 0);
	fUpdateListFB(iRoom, ciList_MTRX_AdminVSrc, 0);

	fSetListFB(iRoom, ciList_MTRX_AdminVDst, 0, 0);
	fUpdateListFB(iRoom, ciList_MTRX_AdminVDst, 0);

	Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected			= 0;
	Room[iRoom].List[ciList_MTRX_AdminVDst].iNumOfItemsSelected		= 0;

	fUpdateConfMonitorRte(iRoom, 0);

}

PUSH MTRX_SelAll
{
	INTEGER iRoom;
	iRoom = getlastmodifiedarrayindex();

	fSetListFB(iRoom, ciList_MTRX_AdminVDst, 0, 1);
	fUpdateListFB(iRoom, ciList_MTRX_AdminVDst, 0);	

	Room[iRoom].List[ciList_MTRX_AdminVDst].iNumOfItemsSelected	= fGetNumItemsSelected(iRoom, ciList_MTRX_AdminVDst);
}

CHANGE MTRX_AdminVSrc_Clicked
{
	INTEGER iRoom, iIndex;
	iRoom 	= getlastmodifiedarrayindex();
    iIndex 	= MTRX_AdminVSrc_Clicked[iRoom];
 
	if(iIndex)
	{
		//if a source was already selected, drop the FB to that button
		if(Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected)
		{
			Room[iRoom].List[ciList_MTRX_AdminVSrc].Item[Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected].iFB 	= 0;
			fUpdateListFB(iRoom, ciList_MTRX_AdminVSrc, Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected);
	    }
		Room[iRoom].List[ciList_MTRX_AdminVSrc].iItemSelected			= iIndex;
		Room[iRoom].List[ciList_MTRX_AdminVSrc].Item[iIndex].iFB		= 1;
		fUpdateListFB(iRoom, ciList_MTRX_AdminVSrc, iIndex);

		fUpdateConfMonitorRte(iRoom, Room[iRoom].List[ciList_MTRX_AdminVSrc].Item[iIndex].iGUID);

		if(Room[iRoom].iUseSrcListMode) 	fUpdateMacroSrc(iRoom, 1, iIndex);
	}
}

CHANGE MTRX_AdminVDst_Clicked
{
	INTEGER iRoom, iIndex;
	iRoom 	= getlastmodifiedarrayindex();
    iIndex 	= MTRX_AdminVDst_Clicked[iRoom];
 
	//update dst list
	Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iIndex].iFB	= !Room[iRoom].List[ciList_MTRX_AdminVDst].Item[iIndex].iFB;
	fUpdateListFB(iRoom, ciList_MTRX_AdminVDst, iIndex);	
}

CHANGE MTRX_Macro1_Src
{
	INTEGER iRoom, iSrc, iMacro, i;
	SIGNED_INTEGER siSrc;
    iRoom = 1;
	iMacro = getlastmodifiedarrayindex();
    iSrc = MTRX_Macro1_Src[iMacro];

	fUpdateMacroSrc(iRoom, iMacro, iSrc);

	if(Sys.iRCState)
	{
		//siSrc = iSrc;
		//iSrc = -siSrc + 8 + ((iSrc-1) * 2);

			 if(iSrc < 5)	iSrc = iSrc + 6;
		else if(iSrc > 5)	iSrc = iSrc - 6;
		fUpdateMacroSrc(fOtherRoom(iRoom), iMacro, iSrc);
	}
}

CHANGE MTRX_Macro2_Src
{
	INTEGER iRoom, iSrc, iMacro, i;
    iRoom = 2;
	iMacro = getlastmodifiedarrayindex();
    iSrc = MTRX_Macro2_Src[iMacro];

	fUpdateMacroSrc(iRoom, iMacro, iSrc);

	if(Sys.iRCState)
	{
		//siSrc = iSrc;
		//iSrc = -siSrc + 8 + ((iSrc-1) * 2);

			 if(iSrc < 5)	iSrc = iSrc + 6;
		else if(iSrc > 5)	iSrc = iSrc - 6;
		fUpdateMacroSrc(fOtherRoom(iRoom), iMacro, iSrc);
	}

}
 
CHANGE MTRX_Macro1_Dst
{
	INTEGER iRoom, iDst, i;
    iRoom = 1;
    iDst = MTRX_Macro1_Dst[1];

	fUpdateMacroDst(iRoom, iDst);
}
CHANGE MTRX_Macro2_Dst
{
	INTEGER iRoom, iDst, i;
    iRoom = 2;
    iDst = MTRX_Macro2_Dst[1];

	fUpdateMacroDst(iRoom, iDst);
}


//-----------------------------------------------------------------------------------------------------//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CAM Ctrl
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//
  

PUSH Cam_Tilt_Up
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "pantilt_up");
}
PUSH Cam_Tilt_Dn
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "pantilt_down");
}
PUSH Cam_Pan_Left
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "pantilt_left");
}
PUSH Cam_Pan_Right
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "pantilt_right");
}
PUSH Cam_Zoom_Tight
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "zoom_in");
}
PUSH Cam_Zoom_Wide
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "zoom_out");
}
PUSH Cam_Power_On
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "power_on");
}
PUSH Cam_Power_Off
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "power_off");
}

RELEASE Cam_Tilt_Up, Cam_Tilt_Dn, Cam_Pan_Left, Cam_Pan_Right, Cam_Focus_Near, Cam_Focus_Far
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "pantilt_stop");
}

RELEASE Cam_Zoom_Tight, Cam_Zoom_Wide
{
	fCamCmdSend(getlastmodifiedarrayindex(), 0, "zoom_stop");
}

CHANGE Cam_Select
{
	INTEGER i, iFB, iRoom;
	STRING sTemp[100];
	
    iRoom = getlastmodifiedarrayindex();
	Room[iRoom].iCamSel	= Cam_Select[iRoom];	

	fUpdateCamFB(iRoom);
                         
	if(Room[iRoom].iCamSel) fUpdateMacroSrc( iRoom, ciMacroConf, Room[iRoom].Cam[Room[iRoom].iCamSel].iVSrcLocalID	);
}


//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//
    
FUNCTION fUpdateGUI(INTEGER iRoom, INTEGER iPage, INTEGER iSub)
{
	INTEGER i;
    
	if(iPage  &&  iSub)
	{
		if(Room[iRoom].iLastSrcSel[iPage][iSub])
		{
			fUpdateConfMonitorRte( iRoom, Room[iRoom].iLastSrcSel[iPage][iSub] );
		}
	}
}

CHANGE UI_Page
{
	INTEGER iRoom;
	iRoom = getlastmodifiedarrayindex();

	Room[iRoom].iUI_Page = UI_Page[iRoom];

	fUpdateGUI(iRoom, Room[iRoom].iUI_Page, Room[iRoom].iUI_Sub);
}

CHANGE UI_Sub
{
 	INTEGER iRoom;
	iRoom = getlastmodifiedarrayindex();

	Room[iRoom].iUI_Sub = UI_Sub[iRoom];

	fUpdateGUI(iRoom, Room[iRoom].iUI_Page, Room[iRoom].iUI_Sub);
}


//-----------------------------------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------------------------------//


THREADSAFE CHANGE from_Global_Rx$_1
{
	STRING sTemp[1000];

	while(find("}", from_Global_Rx$_1[1]))
	{		
    	sTemp = gather("}", from_Global_Rx$_1[1]);
		fProcessData(1, sTemp);
	}
}

THREADSAFE CHANGE from_Global_Rx$_2
{
	STRING sTemp[1000];

	while(find("}", from_Global_Rx$_2[1]))
	{		
    	sTemp = gather("}", from_Global_Rx$_2[1]);
		fProcessData(2, sTemp);
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

FUNCTION main()
{
	INTEGER i, j, l;
	waitforinitializationcomplete();
        
    for(i = 1 to 2)
	{
		for(l = 1 to 2)
    	{
			for(j = 4 to 6)
			{
        		Room[i].List[l].Item[j].iIsVirtual	= 1;
			}
		}
	}
	
	for(i = 1 to 2)
	{
    	Room[i].List[1].iMaxNumItems	= 30;				//admin mtrx src list
    	Room[i].List[1].iNumOfTextColumns	= 1;
    	Room[i].List[1].iListUsesFB		= 1;
    	Room[i].List[1].iListUsesVis	= 1;
    	Room[i].List[1].iListUsesIcon	= 0;
    	Room[i].List[1].iListUsesText	= 1;

    	Room[i].List[2].iMaxNumItems	= 30;				//admin mtrx dst list
    	Room[i].List[2].iNumOfTextColumns	= 2;
    	Room[i].List[2].iListUsesFB		= 1;
    	Room[i].List[2].iListUsesVis	= 1;
    	Room[i].List[2].iListUsesIcon	= 0;
    	Room[i].List[2].iListUsesText	= 1;

    	Room[i].List[3].iMaxNumItems	= 24;				//admin dsp mics list
    	Room[i].List[3].iNumOfTextColumns	= 1;
    	Room[i].List[3].iListUsesFB		= 0;
    	Room[i].List[3].iListUsesVis	= 1;
    	Room[i].List[3].iListUsesIcon	= 0;
    	Room[i].List[3].iListUsesText	= 1;

    	Room[i].List[4].iMaxNumItems	= 15;				//admin dsp line list
    	Room[i].List[4].iNumOfTextColumns	= 1;
    	Room[i].List[4].iListUsesFB		= 0;
    	Room[i].List[4].iListUsesVis	= 1;
    	Room[i].List[4].iListUsesIcon	= 0;
    	Room[i].List[4].iListUsesText	= 1;
		
    	Room[i].List[5].iMaxNumItems	= 9;				//main page mtrx src lists (folded into 1 list fb output)
    	Room[i].List[5].iNumOfTextColumns	= 1;
    	Room[i].List[5].iListUsesFB		= 1;
    	Room[i].List[5].iListUsesVis	= 1;
    	Room[i].List[5].iListUsesIcon	= 0;
    	Room[i].List[5].iListUsesText	= 1;

		for(j = 1 to 9)
		{
        	Room[i].List[5].Item[j].iItemActive	= 1;
			Room[i].List[5].Item[j+20].iItemActive	= 1;
		}
	}	

	Sys.iPartitionEnabled	= 1;
	Sys.iRCState			= !PartSenseSignal[1];
	for(i = 1 to 2)
	{
		PartSense_Enable_FB[i] = 1;
       	RC_Off_FB[i]	= !PartSenseSignal[1];
		RC_On_FB[i]		= PartSenseSignal[1];           
	
		for(j = 1 to ciMaxNumCams)
			Room[i].Cam[j].iVSrcLocalID		= j+20;
		for(j = 1 to ciMaxNumDisplays)
			Room[i].Display[j].iVDstLocalID	= j;
	}
                                            
}


